#!/usr/bin/env bash

# Copyright 2026 txrx-byte
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

###############################################################################
# ashchan – All-in-one CLI for the Ashchan imageboard platform
#
# Usage:  ./ashchan <command> [options]
#
# Commands:
#   install          Full first-time setup (deps, certs, env, db, services)
#   start            Start all services (or a specific one)
#   stop             Stop all services (or a specific one)
#   restart          Restart all services (or a specific one)
#   status           Show service status and health
#   logs             Tail combined service logs
#   db:install       Run the database schema installer
#   db:seed          Seed the database with initial data
#   db:reset         Drop and recreate the database
#   certs:init       Generate the root CA
#   certs:generate   Generate all service certificates
#   certs:rotate     Rotate service certificates
#   certs:status     Show certificate expiry info
#   certs:verify     Verify mTLS chain
#   anubis:start     Start the Anubis AI firewall
#   anubis:stop      Stop the Anubis AI firewall
#   anubis:restart   Restart the Anubis AI firewall
#   anubis:status    Show Anubis status
#   compile          Install composer dependencies for all services
#   build            Build all static binaries (static-php-cli)
#   build:php        Build only the static PHP runtime
#   build:clean      Remove static build artifacts
#   build:<service>  Build static binary for one service
#   firewall:setup   Configure firewall, fail2ban, and sysctl hardening
#   nginx:setup      Configure nginx reverse proxy (TLS + rate limits)
#   nginx:start      Start nginx
#   nginx:stop       Stop nginx
#   nginx:reload     Reload nginx configuration
#   nginx:status     Show nginx status
#   lint             Lint all PHP source files
#   test             Run test suites
#   clean            Remove runtime artifacts and logs
#   help             Show this help
###############################################################################

set -euo pipefail

# ─────────────────────────────────────────────────────────────────────────────
# Globals
# ─────────────────────────────────────────────────────────────────────────────

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PID_DIR="/tmp/ashchan-pids"
LOG_DIR="/tmp"

# Service definitions: name:directory:port
declare -a SVC_NAMES=(gateway auth boards media search moderation)
declare -A SVC_DIRS=(
    [gateway]=api-gateway
    [auth]=auth-accounts
    [boards]=boards-threads-posts
    [media]=media-uploads
    [search]=search-indexing
    [moderation]=moderation-anti-spam
)
declare -A SVC_PORTS=(
    [gateway]=9501  [auth]=9502  [boards]=9503
    [media]=9504    [search]=9505 [moderation]=9506
)
declare -A SVC_MTLS_PORTS=(
    [gateway]=8443  [auth]=8444  [boards]=8445
    [media]=8446    [search]=8447 [moderation]=8448
)
declare -A SVC_LABELS=(
    [gateway]="API Gateway"     [auth]="Auth / Accounts"
    [boards]="Boards / Threads" [media]="Media / Uploads"
    [search]="Search / Index"   [moderation]="Moderation"
)

# Paths
CERTS_DIR="${SCRIPT_DIR}/certs"
CA_DIR="${CERTS_DIR}/ca"
SERVICES_DIR="${CERTS_DIR}/services"
DB_DIR="${SCRIPT_DIR}/db"
ANUBIS_DIR="${SCRIPT_DIR}/config/anubis"
BUILD_SCRIPT="${SCRIPT_DIR}/build/static-php/build.sh"
STATIC_DIST="${SCRIPT_DIR}/build/static-php/dist"
ANUBIS_BIN="$(command -v anubis 2>/dev/null || echo '/usr/local/bin/anubis')"
ANUBIS_PORT=8080
ANUBIS_METRICS_PORT=9091

# Database defaults (override via env)
DB_HOST="${DB_HOST:-localhost}"
DB_PORT="${DB_PORT:-5432}"
DB_USER="${DB_USER:-ashchan}"
DB_NAME="${DB_NAME:-ashchan}"
DB_PASS="${DB_PASS:-ashchan}"
REDIS_HOST="${REDIS_HOST:-localhost}"
REDIS_PASSWORD="${REDIS_PASSWORD:-}"

# ─────────────────────────────────────────────────────────────────────────────
# Colours & formatting
# ─────────────────────────────────────────────────────────────────────────────

if [[ -t 1 ]]; then
    R='\033[0;31m'  G='\033[0;32m'  Y='\033[1;33m'
    B='\033[0;34m'  C='\033[0;36m'  M='\033[0;35m'
    BOLD='\033[1m'  DIM='\033[2m'   NC='\033[0m'
else
    R='' G='' Y='' B='' C='' M='' BOLD='' DIM='' NC=''
fi

# ─────────────────────────────────────────────────────────────────────────────
# Output helpers
# ─────────────────────────────────────────────────────────────────────────────

banner() {
    echo
    echo -e "${M}══════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${M} ▄▀█ █▀ █░█ █▀▀ █░█ █▀█ █▄░█${NC}"
    echo -e "${BOLD}${M} █▀█ ▄█ █▀█ █▄▄ █▀█ █▀█ █░▀█${NC}"
    echo -e "${M}══════════════════════════════════════════════════${NC}"
    if [[ -n "${1:-}" ]]; then
        echo -e "${DIM}  $1${NC}"
    fi
    echo
}

info()    { echo -e "  ${B}●${NC} $1"; }
success() { echo -e "  ${G}✓${NC} $1"; }
warn()    { echo -e "  ${Y}⚠${NC} $1"; }
fail()    { echo -e "  ${R}✗${NC} $1"; }
step()    { echo -e "\n${C}━━━ $1 ━━━${NC}"; }
die()     { fail "$1"; exit 1; }

spin() {
    local pid=$1 msg=$2
    local frames=('⠋' '⠙' '⠹' '⠸' '⠼' '⠴' '⠦' '⠧' '⠇' '⠏')
    local i=0
    while kill -0 "$pid" 2>/dev/null; do
        printf "\r  ${C}%s${NC} %s" "${frames[i]}" "$msg"
        i=$(( (i + 1) % ${#frames[@]} ))
        sleep 0.08
    done
    printf "\r"
}

confirm() {
    local msg="${1:-Continue?}"
    echo -en "  ${Y}?${NC} ${msg} ${DIM}[y/N]${NC} "
    read -r -n 1 reply
    echo
    [[ "$reply" =~ ^[Yy]$ ]]
}

separator() {
    echo -e "${DIM}  ──────────────────────────────────────────────${NC}"
}

# ─────────────────────────────────────────────────────────────────────────────
# Auto-install prerequisites
# ─────────────────────────────────────────────────────────────────────────────

install_prerequisites() {
    step "Installing system prerequisites"

    if command -v apk &>/dev/null; then
        info "Detected Alpine Linux (apk)"
        # Determine installed PHP major version or default to 84
        local php_pkg_prefix="php84"
        if command -v php83 &>/dev/null && ! command -v php84 &>/dev/null; then
            php_pkg_prefix="php83"
        fi
        info "Using package prefix: ${php_pkg_prefix}"

        local pkgs=(
            "${php_pkg_prefix}" "${php_pkg_prefix}-openssl" "${php_pkg_prefix}-pdo"
            "${php_pkg_prefix}-pdo_pgsql" "${php_pkg_prefix}-mbstring"
            "${php_pkg_prefix}-curl" "${php_pkg_prefix}-pcntl"
            "${php_pkg_prefix}-phar" "${php_pkg_prefix}-iconv"
            "${php_pkg_prefix}-dom" "${php_pkg_prefix}-xml"
            "${php_pkg_prefix}-xmlwriter" "${php_pkg_prefix}-tokenizer"
            "${php_pkg_prefix}-fileinfo" "${php_pkg_prefix}-ctype"
            "${php_pkg_prefix}-posix" "${php_pkg_prefix}-session"
            "${php_pkg_prefix}-sockets" "${php_pkg_prefix}-gd"
            "${php_pkg_prefix}-pecl-swoole" "${php_pkg_prefix}-pecl-redis"
            openssl composer postgresql16 postgresql16-client postgresql16-contrib redis make
        )

        info "Installing packages (this may take a moment)..."
        if sudo apk add --no-cache "${pkgs[@]}" 2>/dev/null; then
            success "APK packages installed"
        else
            # Retry without --no-cache and ignore individual failures
            warn "Some packages failed — retrying with relaxed options..."
            for pkg in "${pkgs[@]}"; do
                sudo apk add "$pkg" 2>/dev/null || warn "Could not install ${pkg}"
            done
        fi

        # Create php symlink if not present
        if ! command -v php &>/dev/null; then
            local php_bin
            php_bin=$(command -v "${php_pkg_prefix}" 2>/dev/null || which "${php_pkg_prefix}" 2>/dev/null || echo "")
            if [[ -n "$php_bin" ]]; then
                sudo ln -sf "$php_bin" /usr/local/bin/php
                success "Created php symlink → ${php_bin}"
            fi
        fi

    elif command -v apt-get &>/dev/null; then
        info "Detected Debian/Ubuntu (apt)"
        sudo apt-get update -qq 2>/dev/null

        local pkgs=(
            php8.2 php8.2-cli php8.2-swoole php8.2-pgsql php8.2-redis
            php8.2-mbstring php8.2-curl php8.2-xml php8.2-dom php8.2-gd
            openssl composer postgresql-client redis-server make
        )

        info "Installing packages (this may take a moment)..."
        if sudo apt-get install -y -qq "${pkgs[@]}" 2>/dev/null; then
            success "APT packages installed"
        else
            warn "Some packages failed — retrying individually..."
            for pkg in "${pkgs[@]}"; do
                sudo apt-get install -y -qq "$pkg" 2>/dev/null || warn "Could not install ${pkg}"
            done
        fi

    elif command -v dnf &>/dev/null; then
        info "Detected Fedora/RHEL (dnf)"
        local pkgs=(
            php php-cli php-swoole php-pgsql php-redis php-mbstring
            php-curl php-xml php-gd php-openssl
            openssl composer postgresql redis make
        )
        sudo dnf install -y -q "${pkgs[@]}" 2>/dev/null || warn "Some packages may have failed"
        success "DNF packages installed"

    elif command -v pkg &>/dev/null; then
        info "Detected FreeBSD (pkg)"
        local pkgs=(
            php84 php84-extensions php84-swoole php84-pdo_pgsql php84-redis
            php84-mbstring php84-curl php84-xml php84-gd
            openssl composer postgresql16-client redis
        )
        sudo pkg install -y "${pkgs[@]}" 2>/dev/null || warn "Some packages may have failed"
        success "FreeBSD packages installed"

    else
        warn "No supported package manager found (apk, apt, dnf, pkg)"
        info "Please install manually: PHP 8.2+, Swoole, PostgreSQL client, Redis, Composer, OpenSSL, Make"
        return 1
    fi

    # Ensure Redis server is running
    provision_redis

    success "Prerequisite installation complete"
}

# Start Redis if installed but not running
provision_redis() {
    if redis-cli -h "$REDIS_HOST" ping &>/dev/null 2>&1; then
        success "Redis already running on ${REDIS_HOST}"
        return 0
    fi

    if ! command -v redis-server &>/dev/null; then
        # Try installing Redis
        if command -v apk &>/dev/null; then
            sudo apk add --no-cache redis 2>/dev/null || true
        elif command -v apt-get &>/dev/null; then
            sudo apt-get install -y -qq redis-server 2>/dev/null || true
        fi
    fi

    if command -v redis-server &>/dev/null; then
        info "Starting Redis server..."
        if command -v rc-service &>/dev/null; then
            sudo rc-service redis start 2>/dev/null || true
        elif command -v systemctl &>/dev/null; then
            sudo systemctl start redis-server 2>/dev/null || sudo systemctl start redis 2>/dev/null || true
        else
            # Fallback: start in background
            redis-server --daemonize yes 2>/dev/null || sudo redis-server --daemonize yes 2>/dev/null || true
        fi
        sleep 1
        if redis-cli -h "$REDIS_HOST" ping &>/dev/null 2>&1; then
            success "Redis started on ${REDIS_HOST}"
            return 0
        else
            warn "Redis installed but failed to start"
            return 1
        fi
    else
        warn "Redis not available — install it and start with: redis-server --daemonize yes"
        return 1
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Prerequisite checks
# ─────────────────────────────────────────────────────────────────────────────

check_php() {
    command -v php &>/dev/null || die "PHP not found. Install PHP 8.2+ with Swoole."
    local ver
    ver=$(php -r "echo PHP_MAJOR_VERSION.'.'.PHP_MINOR_VERSION;")
    success "PHP ${ver}"
}

check_php_extensions() {
    local required=(swoole openssl pdo pdo_pgsql redis mbstring json curl pcntl gd fileinfo)
    local missing=()
    for ext in "${required[@]}"; do
        if ! php -m 2>/dev/null | grep -qiE "^${ext}\$"; then
            missing+=("$ext")
        fi
    done
    if [[ ${#missing[@]} -gt 0 ]]; then
        fail "Missing PHP extensions: ${missing[*]}"
        info "Install them:  sudo apk add php-swoole php-pgsql php-redis php-gd php-fileinfo"
        return 1
    fi
    success "All required PHP extensions present"
}

check_composer() {
    command -v composer &>/dev/null || die "Composer not found. Install composer globally."
    success "Composer $(composer --version 2>/dev/null | head -1 | grep -oP '[\d.]+')"
}

check_openssl() {
    command -v openssl &>/dev/null || die "OpenSSL not found."
    success "OpenSSL available"
}

check_psql() {
    if command -v psql &>/dev/null; then
        success "psql client available"
        return 0
    else
        warn "psql not found — database operations will be skipped"
        return 1
    fi
}

check_redis() {
    if redis-cli -h "$REDIS_HOST" ping &>/dev/null; then
        success "Redis responding on ${REDIS_HOST}"
        return 0
    else
        warn "Redis not responding on ${REDIS_HOST}"
        return 1
    fi
}

check_db() {
    if ! command -v psql &>/dev/null; then return 1; fi
    if PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" -c "SELECT 1" &>/dev/null; then
        success "PostgreSQL connection OK (${DB_USER}@${DB_HOST}:${DB_PORT}/${DB_NAME})"
        return 0
    else
        warn "Cannot connect to PostgreSQL (${DB_USER}@${DB_HOST}:${DB_PORT}/${DB_NAME})"
        return 1
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Anubis (Web AI Firewall)
# ─────────────────────────────────────────────────────────────────────────────

check_anubis() {
    if [[ -x "$ANUBIS_BIN" ]]; then
        local ver
        ver=$("$ANUBIS_BIN" 2>&1 | head -1 || echo "unknown")
        success "Anubis available at ${ANUBIS_BIN}"
        return 0
    else
        warn "Anubis not found at ${ANUBIS_BIN}"
        info "Install: download from https://github.com/TecharoHQ/anubis/releases"
        return 1
    fi
}

anubis_is_running() {
    local pidfile="${PID_DIR}/anubis.pid"
    if [[ -f "$pidfile" ]]; then
        local pid
        pid=$(cat "$pidfile")
        if kill -0 "$pid" 2>/dev/null; then
            return 0
        fi
        rm -f "$pidfile"
    fi
    return 1
}

anubis_pid() {
    local pidfile="${PID_DIR}/anubis.pid"
    if [[ -f "$pidfile" ]]; then
        cat "$pidfile"
    fi
}

anubis_start() {
    ensure_pid_dir
    if anubis_is_running; then
        info "Anubis already running (PID $(anubis_pid))"
        return 0
    fi
    if [[ ! -x "$ANUBIS_BIN" ]]; then
        warn "Anubis binary not found — skipping"
        return 1
    fi
    if [[ ! -f "${ANUBIS_DIR}/env" ]]; then
        warn "Anubis env file not found at ${ANUBIS_DIR}/env — skipping"
        return 1
    fi

    # Source env file and export variables
    set -a
    # shellcheck source=/dev/null
    source "${ANUBIS_DIR}/env"
    set +a

    nohup "$ANUBIS_BIN" > "${LOG_DIR}/ashchan-anubis.log" 2>&1 &
    local pid=$!
    echo "$pid" > "${PID_DIR}/anubis.pid"
    sleep 0.5
    if kill -0 "$pid" 2>/dev/null; then
        success "Anubis started (PID ${pid}, port ${ANUBIS_PORT} → gateway:${SVC_PORTS[gateway]})"
    else
        fail "Anubis failed to start — check ${LOG_DIR}/ashchan-anubis.log"
        rm -f "${PID_DIR}/anubis.pid"
        return 1
    fi
}

anubis_stop() {
    if anubis_is_running; then
        local pid
        pid=$(anubis_pid)
        kill "$pid" 2>/dev/null || true
        sleep 0.5
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null || true
        fi
        rm -f "${PID_DIR}/anubis.pid"
        success "Anubis stopped (was PID ${pid})"
    else
        info "Anubis not running"
    fi
}

anubis_health() {
    if curl -s --max-time 2 "http://localhost:${ANUBIS_PORT}/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# ─────────────────────────────────────────────────────────────────────────────
# Service control
# ─────────────────────────────────────────────────────────────────────────────

ensure_pid_dir() { mkdir -p "$PID_DIR"; }

svc_pid() {
    local name=$1
    local pidfile="${PID_DIR}/${name}.pid"
    if [[ -f "$pidfile" ]]; then
        local pid
        pid=$(cat "$pidfile")
        if kill -0 "$pid" 2>/dev/null; then
            echo "$pid"
            return 0
        fi
        rm -f "$pidfile"
    fi
    return 1
}

svc_is_running() { svc_pid "$1" &>/dev/null; }

svc_start() {
    local name=$1
    ensure_pid_dir
    if svc_is_running "$name"; then
        info "${SVC_LABELS[$name]} already running (PID $(svc_pid "$name"))"
        return 0
    fi
    local dir="${SCRIPT_DIR}/services/${SVC_DIRS[$name]}"
    if [[ ! -d "$dir" ]]; then
        fail "Service directory not found: $dir"
        return 1
    fi
    cd "$dir"
    nohup php bin/hyperf.php start > "${LOG_DIR}/ashchan-${name}.log" 2>&1 &
    local pid=$!
    echo "$pid" > "${PID_DIR}/${name}.pid"
    # Brief check that process didn't die immediately
    sleep 0.3
    if kill -0 "$pid" 2>/dev/null; then
        success "${SVC_LABELS[$name]} started (PID ${pid}, port ${SVC_PORTS[$name]})"
    else
        fail "${SVC_LABELS[$name]} failed to start — check ${LOG_DIR}/ashchan-${name}.log"
        rm -f "${PID_DIR}/${name}.pid"
        return 1
    fi
    cd "$SCRIPT_DIR"
}

svc_stop() {
    local name=$1
    local pid
    if pid=$(svc_pid "$name"); then
        # Kill the master and all workers
        kill "$pid" 2>/dev/null || true
        # Also kill any child workers with the same group ID
        pkill -P "$pid" 2>/dev/null || true
        sleep 0.5
        # Force kill if still alive
        if kill -0 "$pid" 2>/dev/null; then
            kill -9 "$pid" 2>/dev/null || true
            pkill -9 -P "$pid" 2>/dev/null || true
        fi
        rm -f "${PID_DIR}/${name}.pid"
        success "${SVC_LABELS[$name]} stopped (was PID ${pid})"
    else
        info "${SVC_LABELS[$name]} not running"
    fi
}

svc_health() {
    local name=$1
    local port=${SVC_PORTS[$name]}
    if curl -s --max-time 2 "http://localhost:${port}/health" &>/dev/null; then
        return 0
    fi
    return 1
}

# ─────────────────────────────────────────────────────────────────────────────
# mTLS certificates
# ─────────────────────────────────────────────────────────────────────────────

certs_init_ca() {
    step "Generating Root CA (ECDSA P-256, 10 year)"
    mkdir -p "$CA_DIR" "$SERVICES_DIR"

    if [[ -f "${CA_DIR}/ca.crt" ]] && [[ -f "${CA_DIR}/ca.key" ]]; then
        if [[ "${FORCE:-}" != "1" ]]; then
            info "CA already exists (use --force to regenerate)"
            return 0
        fi
    fi

    openssl ecparam -genkey -name prime256v1 -noout -out "${CA_DIR}/ca.key" 2>/dev/null
    chmod 644 "${CA_DIR}/ca.key"

    openssl req -new -x509 -sha256 -days 3650 \
        -key "${CA_DIR}/ca.key" \
        -out "${CA_DIR}/ca.crt" \
        -subj "/C=US/ST=California/L=San Francisco/O=Ashchan/OU=ServiceMesh/CN=ashchan-ca" \
        -addext "basicConstraints=critical,CA:TRUE" \
        -addext "keyUsage=critical,keyCertSign,cRLSign" \
        -addext "subjectKeyIdentifier=hash" 2>/dev/null

    touch "${CA_DIR}/index.txt"
    echo "1000" > "${CA_DIR}/serial"
    echo "1000" > "${CA_DIR}/crlnumber"
    cp "${CA_DIR}/ca.crt" "${SERVICES_DIR}/ca.crt"

    success "Root CA generated"
}

cert_generate_one() {
    local name=$1 dns="${2:-localhost}"
    local svc_cert_dir="${SERVICES_DIR}/${name}"
    mkdir -p "$svc_cert_dir"

    if [[ -f "${svc_cert_dir}/${name}.crt" ]] && [[ "${FORCE:-}" != "1" ]]; then
        info "${name} certificate already exists"
        return 0
    fi

    # Remove old
    rm -f "${svc_cert_dir}/${name}.crt" "${svc_cert_dir}/${name}.key" \
          "${svc_cert_dir}/${name}.csr" "${svc_cert_dir}/${name}.ext" \
          "${SERVICES_DIR}/${name}.crt" "${SERVICES_DIR}/${name}.key"

    openssl ecparam -genkey -name prime256v1 -noout -out "${svc_cert_dir}/${name}.key" 2>/dev/null
    chmod 600 "${svc_cert_dir}/${name}.key"

    openssl req -new \
        -key "${svc_cert_dir}/${name}.key" \
        -out "${svc_cert_dir}/${name}.csr" \
        -subj "/C=US/ST=California/L=San Francisco/O=Ashchan/OU=ServiceMesh/CN=${dns}" 2>/dev/null

    cat > "${svc_cert_dir}/${name}.ext" <<EOF
basicConstraints = CA:FALSE
nsCertType = server, client
subjectKeyIdentifier = hash
authorityKeyIdentifier = keyid,issuer:always
keyUsage = critical, digitalSignature, keyEncipherment
extendedKeyUsage = serverAuth, clientAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = ${dns}
DNS.2 = ${name}.ashchan.local
DNS.3 = ${name}
DNS.4 = ashchan-${name}-1
DNS.5 = localhost
EOF

    openssl x509 -req \
        -in "${svc_cert_dir}/${name}.csr" \
        -CA "${CA_DIR}/ca.crt" -CAkey "${CA_DIR}/ca.key" -CAcreateserial \
        -out "${svc_cert_dir}/${name}.crt" \
        -days 365 -sha256 \
        -extfile "${svc_cert_dir}/${name}.ext" 2>/dev/null

    cp "${svc_cert_dir}/${name}.crt" "${SERVICES_DIR}/${name}.crt"
    cp "${svc_cert_dir}/${name}.key" "${SERVICES_DIR}/${name}.key"
    rm -f "${svc_cert_dir}/${name}.csr" "${svc_cert_dir}/${name}.ext"

    success "${name} certificate issued (365 days)"
}

certs_generate_all() {
    step "Generating service certificates"
    if [[ ! -f "${CA_DIR}/ca.crt" ]]; then
        certs_init_ca
    fi
    for svc in "${SVC_NAMES[@]}"; do
        cert_generate_one "$svc" "localhost"
    done
}

certs_verify() {
    step "Verifying mTLS certificate chain"
    if [[ ! -f "${CA_DIR}/ca.crt" ]]; then
        fail "Root CA not found – run: ./ashchan certs:init"
        return 1
    fi
    local ok=0 total=0
    for svc in "${SVC_NAMES[@]}"; do
        total=$((total + 1))
        local cert="${SERVICES_DIR}/${svc}/${svc}.crt"
        if [[ ! -f "$cert" ]]; then
            fail "${svc} — certificate missing"
            continue
        fi
        if openssl verify -CAfile "${CA_DIR}/ca.crt" "$cert" &>/dev/null; then
            success "${svc} — valid"
            ok=$((ok + 1))
        else
            fail "${svc} — verification failed"
        fi
    done
    echo
    if [[ $ok -eq $total ]]; then
        success "All ${total} certificates valid"
    else
        warn "${ok}/${total} certificates valid"
    fi
}

certs_status() {
    step "Certificate expiry status"
    if [[ ! -f "${CA_DIR}/ca.crt" ]]; then
        fail "No CA found"
        return 1
    fi
    for svc in "${SVC_NAMES[@]}"; do
        local cert="${SERVICES_DIR}/${svc}/${svc}.crt"
        if [[ ! -f "$cert" ]]; then
            info "${svc}: ${R}not generated${NC}"
            continue
        fi
        local expiry days_left
        expiry=$(openssl x509 -in "$cert" -noout -enddate 2>/dev/null | cut -d= -f2)
        if date --version &>/dev/null 2>&1; then
            days_left=$(( ( $(date -d "$expiry" +%s) - $(date +%s) ) / 86400 ))
        else
            days_left=$(( ( $(date -j -f "%b %d %H:%M:%S %Y %Z" "$expiry" +%s 2>/dev/null || echo 0) - $(date +%s) ) / 86400 ))
        fi
        if [[ $days_left -lt 30 ]]; then
            warn "${svc}: expires in ${days_left} days  ⟵ renew soon"
        else
            success "${svc}: expires in ${days_left} days"
        fi
    done
}

certs_rotate() {
    step "Rotating service certificates"
    if [[ ! -f "${CA_DIR}/ca.crt" ]]; then
        die "No CA found — run ./ashchan certs:init first"
    fi

    if ! confirm "This will regenerate all service certs and restart running services."; then
        info "Aborted"
        return 0
    fi

    # Backup
    local backup="${CERTS_DIR}/backup/$(date +%Y%m%d_%H%M%S)"
    mkdir -p "$backup"
    for svc in "${SVC_NAMES[@]}"; do
        [[ -d "${SERVICES_DIR}/${svc}" ]] && cp -r "${SERVICES_DIR}/${svc}" "$backup/"
    done
    success "Backup → ${backup}"

    # Regenerate
    FORCE=1
    for svc in "${SVC_NAMES[@]}"; do
        cert_generate_one "$svc" "localhost"
    done
    unset FORCE

    # Rolling restart of running services
    local restarted=0
    for svc in "${SVC_NAMES[@]}"; do
        if svc_is_running "$svc"; then
            svc_stop "$svc"
            sleep 1
            svc_start "$svc"
            sleep 2
            restarted=$((restarted + 1))
        fi
    done
    [[ $restarted -gt 0 ]] && success "Restarted ${restarted} running service(s)"
    success "Certificate rotation complete"
}

# ─────────────────────────────────────────────────────────────────────────────
# Environment files
# ─────────────────────────────────────────────────────────────────────────────

setup_env_files() {
    step "Configuring service .env files"
    for svc in "${SVC_NAMES[@]}"; do
        local dir="${SCRIPT_DIR}/services/${SVC_DIRS[$svc]}"
        local envfile="${dir}/.env"
        local example="${dir}/.env.example"
        if [[ -f "$envfile" ]] && [[ "${FORCE:-}" != "1" ]]; then
            info "${SVC_DIRS[$svc]}/.env already exists"
            continue
        fi
        if [[ ! -f "$example" ]]; then
            warn "No .env.example for ${SVC_DIRS[$svc]}"
            continue
        fi
        sed -e "s|__PROJECT_ROOT__|${SCRIPT_DIR}|g" \
            -e "s|__DB_HOST__|${DB_HOST}|g" \
            -e "s|__REDIS_HOST__|${REDIS_HOST}|g" \
            -e "s|__REDIS_PASSWORD__|${REDIS_PASSWORD}|g" \
            -e "s|__REDIS_AUTH__|${REDIS_PASSWORD}|g" \
            "$example" > "$envfile"
        success "${SVC_DIRS[$svc]}/.env created"
    done
}

# ─────────────────────────────────────────────────────────────────────────────
# Composer / compile
# ─────────────────────────────────────────────────────────────────────────────

compile_services() {
    step "Installing composer dependencies"
    local ok=0 total=0
    for svc in "${SVC_NAMES[@]}"; do
        total=$((total + 1))
        local dir="${SCRIPT_DIR}/services/${SVC_DIRS[$svc]}"
        if [[ ! -f "${dir}/composer.json" ]]; then
            warn "${SVC_DIRS[$svc]}: no composer.json"
            continue
        fi
        info "Installing ${SVC_LABELS[$svc]}..."
        if (cd "$dir" && composer install --no-interaction --quiet 2>/dev/null); then
            success "${SVC_LABELS[$svc]} dependencies installed"
            ok=$((ok + 1))
        else
            fail "${SVC_LABELS[$svc]} composer install failed"
        fi
    done
    echo
    if [[ $ok -eq $total ]]; then
        success "All ${total} services compiled"
    else
        warn "${ok}/${total} services compiled"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Database
# ─────────────────────────────────────────────────────────────────────────────

# Auto-provision PostgreSQL if not available (for first-time install)
provision_postgres() {
    # Already reachable — nothing to do
    if check_db 2>/dev/null; then return 0; fi

    info "PostgreSQL not reachable — attempting auto-provision..."

    # Install PostgreSQL server + client if not fully present
    if ! command -v psql &>/dev/null || ! command -v pg_ctl &>/dev/null; then
        info "Installing PostgreSQL server and client..."
        if command -v apk &>/dev/null; then
            sudo apk add --no-cache postgresql16 postgresql16-client postgresql16-contrib 2>/dev/null
        elif command -v apt-get &>/dev/null; then
            sudo apt-get install -y -qq postgresql postgresql-client 2>/dev/null
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q postgresql-server postgresql 2>/dev/null
        elif command -v pkg &>/dev/null; then
            sudo pkg install -y postgresql16-server postgresql16-client 2>/dev/null
        else
            warn "No supported package manager found — cannot auto-install PostgreSQL"
            return 1
        fi
    fi

    if ! command -v psql &>/dev/null; then
        warn "PostgreSQL client installation failed"
        return 1
    fi

    if ! command -v pg_ctl &>/dev/null; then
        # On Alpine, pg_ctl may be at a non-standard path (e.g. /usr/libexec/postgresql16/)
        local pg_ctl_path
        pg_ctl_path=$(find /usr -name pg_ctl -type f 2>/dev/null | head -1)
        if [[ -n "$pg_ctl_path" ]]; then
            sudo ln -sf "$pg_ctl_path" /usr/local/bin/pg_ctl
            info "Linked pg_ctl → ${pg_ctl_path}"
        else
            warn "PostgreSQL server (pg_ctl) not found after install"
            return 1
        fi
    fi

    # Also ensure initdb is on PATH
    if ! command -v initdb &>/dev/null; then
        local initdb_path
        initdb_path=$(find /usr -name initdb -type f 2>/dev/null | head -1)
        if [[ -n "$initdb_path" ]]; then
            sudo ln -sf "$initdb_path" /usr/local/bin/initdb
            info "Linked initdb → ${initdb_path}"
        fi
    fi

    # Determine data directory
    local pg_data="/var/lib/postgresql/16/data"
    if [[ "$(uname -s)" == "FreeBSD" ]]; then
        pg_data="/var/db/postgres/data16"
    fi

    # Initialize if needed
    if [[ ! -f "${pg_data}/PG_VERSION" ]]; then
        info "Initializing PostgreSQL data directory..."
        sudo mkdir -p "$(dirname "$pg_data")"
        sudo mkdir -p "$pg_data"
        sudo chown -R postgres:postgres "$(dirname "$pg_data")"
        sudo chown postgres:postgres "$pg_data"

        # Use full path to initdb if needed
        local initdb_bin
        initdb_bin=$(command -v initdb 2>/dev/null || find /usr -name initdb -type f 2>/dev/null | head -1)
        if [[ -z "$initdb_bin" ]]; then
            warn "initdb not found — cannot initialize PostgreSQL"
            return 1
        fi
        # Use sudo to root, then su to postgres (works when sudoers only allows root)
        sudo su postgres -c "'${initdb_bin}' -D '${pg_data}'" &>/dev/null || {
            warn "Failed to initialize PostgreSQL"
            return 1
        }
        # Enable TCP connections with password auth
        echo "host all all 127.0.0.1/32 md5" | sudo tee -a "${pg_data}/pg_hba.conf" >/dev/null
        echo "host all all ::1/128 md5" | sudo tee -a "${pg_data}/pg_hba.conf" >/dev/null
        # Allow local socket trust for postgres admin commands
        sudo sed -i 's/^local.*all.*all.*peer$/local all all trust/' "${pg_data}/pg_hba.conf" 2>/dev/null || true
        sudo sed -i 's/^local.*all.*all.*ident$/local all all trust/' "${pg_data}/pg_hba.conf" 2>/dev/null || true
    fi

    # Ensure runtime dir exists
    sudo mkdir -p /run/postgresql 2>/dev/null
    sudo chown postgres:postgres /run/postgresql 2>/dev/null

    # Resolve pg_ctl full path
    local pg_ctl_bin
    pg_ctl_bin=$(command -v pg_ctl 2>/dev/null || find /usr -name pg_ctl -type f 2>/dev/null | head -1)

    # Start server if not running
    if ! sudo su postgres -c "'${pg_ctl_bin}' -D '${pg_data}' status" &>/dev/null; then
        info "Starting PostgreSQL server..."
        sudo mkdir -p "$(dirname "$pg_data")/log" 2>/dev/null
        sudo chown postgres:postgres "$(dirname "$pg_data")/log" 2>/dev/null
        sudo su postgres -c "'${pg_ctl_bin}' -D '${pg_data}' -l '$(dirname "$pg_data")/logfile' start" &>/dev/null || {
            # Try with -o to listen on localhost
            sudo su postgres -c "'${pg_ctl_bin}' -D '${pg_data}' -l '$(dirname "$pg_data")/logfile' -o '-h localhost' start" &>/dev/null || {
                warn "Failed to start PostgreSQL"
                sudo cat "$(dirname "$pg_data")/logfile" 2>/dev/null | tail -10 || true
                return 1
            }
        }
        sleep 2
    fi

    # Create user and database if they don't exist
    if ! sudo su postgres -c "psql -tAc \"SELECT 1 FROM pg_roles WHERE rolname='${DB_USER}'\"" 2>/dev/null | grep -q 1; then
        info "Creating database user '${DB_USER}'..."
        sudo su postgres -c "psql -c \"CREATE USER ${DB_USER} WITH PASSWORD '${DB_PASS}';\"" &>/dev/null || true
    fi

    if ! sudo su postgres -c "psql -tAc \"SELECT 1 FROM pg_database WHERE datname='${DB_NAME}'\"" 2>/dev/null | grep -q 1; then
        info "Creating database '${DB_NAME}'..."
        sudo su postgres -c "psql -c \"CREATE DATABASE ${DB_NAME} OWNER ${DB_USER};\"" &>/dev/null || true
    fi

    # Grant privileges
    sudo su postgres -c "psql -c \"GRANT ALL PRIVILEGES ON DATABASE ${DB_NAME} TO ${DB_USER};\"" &>/dev/null || true

    # Verify connection
    if check_db 2>/dev/null; then
        success "PostgreSQL auto-provisioned successfully"
        return 0
    else
        warn "PostgreSQL provisioned but connection check failed"
        return 1
    fi
}

db_exec() {
    PGPASSWORD="$DB_PASS" psql -h "$DB_HOST" -p "$DB_PORT" -U "$DB_USER" -d "$DB_NAME" "$@"
}

cmd_db_install() {
    step "Installing database schema"
    if ! check_db; then
        die "Cannot connect to PostgreSQL"
    fi
    local schema="${DB_DIR}/install.sql"
    if [[ ! -f "$schema" ]]; then
        die "Schema file not found: ${schema}"
    fi
    info "Applying ${schema}..."
    if db_exec -f "$schema" &>/dev/null; then
        success "Database schema installed"
    else
        fail "Schema install had errors — some tables may already exist (this is usually OK)"
    fi
}

cmd_db_seed() {
    step "Seeding database"
    if ! check_db; then
        die "Cannot connect to PostgreSQL"
    fi
    local seed="${DB_DIR}/seed.sql"
    if [[ ! -f "$seed" ]]; then
        die "Seed file not found: ${seed}"
    fi
    info "Applying ${seed}..."
    if db_exec -f "$seed" &>/dev/null; then
        success "Database seeded"
        echo
        echo -e "  ${Y}╔════════════════════════════════════════════════╗${NC}"
        echo -e "  ${Y}║  ${BOLD}DEFAULT ADMIN CREDENTIALS${NC}${Y}                       ║${NC}"
        echo -e "  ${Y}║                                                ║${NC}"
        echo -e "  ${Y}║  Username:  ${BOLD}admin${NC}${Y}                               ║${NC}"
        echo -e "  ${Y}║  Password:  ${BOLD}admin123${NC}${Y}                            ║${NC}"
        echo -e "  ${Y}║                                                ║${NC}"
        echo -e "  ${Y}║  ${R}⚠ CHANGE THIS IMMEDIATELY AFTER INSTALL${NC}${Y}      ║${NC}"
        echo -e "  ${Y}╚════════════════════════════════════════════════╝${NC}"
        echo
    else
        fail "Seeding had errors — some data may already exist (generally OK)"
    fi
}

cmd_db_reset() {
    step "Resetting database"
    if ! check_db; then
        die "Cannot connect to PostgreSQL"
    fi
    if ! confirm "This will DROP ALL TABLES and recreate the schema. Proceed?"; then
        info "Aborted"
        return 0
    fi
    info "Dropping all tables..."
    db_exec -c "
        DO \$\$ DECLARE r RECORD;
        BEGIN
            FOR r IN (SELECT tablename FROM pg_tables WHERE schemaname = 'public') LOOP
                EXECUTE 'DROP TABLE IF EXISTS ' || quote_ident(r.tablename) || ' CASCADE';
            END LOOP;
        END \$\$;
    " &>/dev/null && success "All tables dropped" || fail "Drop failed"

    cmd_db_install
    cmd_db_seed
}

# ─────────────────────────────────────────────────────────────────────────────
# Lint & test
# ─────────────────────────────────────────────────────────────────────────────

cmd_lint() {
    step "Linting PHP source files"
    local errors=0 files=0
    for svc in "${SVC_NAMES[@]}"; do
        local dir="${SCRIPT_DIR}/services/${SVC_DIRS[$svc]}"
        [[ -d "${dir}/app" ]] || continue
        while IFS= read -r -d '' f; do
            files=$((files + 1))
            if ! php -l "$f" &>/dev/null; then
                fail "$f"
                errors=$((errors + 1))
            fi
        done < <(find "$dir/app" -name '*.php' -print0 2>/dev/null)
    done
    echo
    if [[ $errors -eq 0 ]]; then
        success "All ${files} files pass syntax check"
    else
        fail "${errors}/${files} files have syntax errors"
    fi
}

cmd_test() {
    step "Running test suites"
    for svc in "${SVC_NAMES[@]}"; do
        local dir="${SCRIPT_DIR}/services/${SVC_DIRS[$svc]}"
        if [[ -f "${dir}/phpunit.xml" ]] || [[ -f "${dir}/phpunit.xml.dist" ]]; then
            info "Testing ${SVC_LABELS[$svc]}..."
            (cd "$dir" && php vendor/bin/phpunit 2>&1 | tail -3) || true
        fi
    done
}

# ─────────────────────────────────────────────────────────────────────────────
# Firewall hardening
# ─────────────────────────────────────────────────────────────────────────────

FIREWALL_STAGE_DIR="${SCRIPT_DIR}/config/firewall"

detect_os() {
    if [[ "$(uname -s)" == "FreeBSD" ]]; then
        echo "freebsd"
    else
        echo "linux"
    fi
}

detect_wan_interface() {
    # Try to find the default route interface
    local iface
    if command -v ip &>/dev/null; then
        iface=$(ip route show default 2>/dev/null | awk '/default/ {print $5; exit}')
    elif command -v route &>/dev/null; then
        iface=$(route -n get default 2>/dev/null | awk '/interface:/ {print $2; exit}')
    fi
    echo "${iface:-eth0}"
}

detect_firewall_backend() {
    local os
    os=$(detect_os)
    if [[ "$os" == "freebsd" ]]; then
        if command -v pfctl &>/dev/null; then
            echo "pf"
        elif command -v ipfw &>/dev/null; then
            echo "ipfw"
        else
            echo "none"
        fi
    else
        if command -v nft &>/dev/null; then
            echo "nftables"
        elif command -v firewall-cmd &>/dev/null; then
            echo "firewalld"
        elif command -v iptables &>/dev/null; then
            echo "iptables"
        else
            echo "none"
        fi
    fi
}

firewall_generate_nftables() {
    local wan_if="$1"
    local outfile="${FIREWALL_STAGE_DIR}/nftables.conf"
    mkdir -p "$FIREWALL_STAGE_DIR"
    cat > "$outfile" <<'NFTEOF'
#!/usr/sbin/nft -f

flush ruleset

# ── Variables ────────────────────────────────────────────────
NFTEOF
    # Write the interface variable (not part of heredoc to interpolate)
    echo "define WAN_IF     = ${wan_if}" >> "$outfile"
    cat >> "$outfile" <<'NFTEOF'
define ASHCHAN_PORTS = { 9501-9506, 8443-8448, 9091 }
define INFRA_PORTS   = { 5432, 6379, 9000, 9001 }

# ── Base tables ──────────────────────────────────────────────
table inet filter {
    # Rate-limit sets
    set ratelimit_ssh {
        type ipv4_addr
        flags dynamic,timeout
        timeout 10m
    }

    set ratelimit_http {
        type ipv4_addr
        flags dynamic,timeout
        timeout 1m
    }

    set blocklist {
        type ipv4_addr
        flags interval
    }

    chain input {
        type filter hook input priority 0; policy drop;

        # ── Fundamentals ──
        ct state established,related accept
        ct state invalid drop
        iif lo accept

        # ── Drop known-bad IPs ──
        ip saddr @blocklist drop

        # ── ICMP (allow ping, limit) ──
        ip protocol icmp icmp type {
            echo-request, echo-reply,
            destination-unreachable, time-exceeded
        } limit rate 10/second accept

        ip6 nexthdr icmpv6 icmpv6 type {
            echo-request, echo-reply,
            nd-neighbor-solicit, nd-neighbor-advert,
            nd-router-solicit, nd-router-advert
        } limit rate 10/second accept

        # ── SSH (rate-limited) ──
        tcp dport 22 ct state new \
            add @ratelimit_ssh { ip saddr limit rate 4/minute burst 8 packets } \
            accept

        # ── Anubis public endpoint (rate-limited) ──
        tcp dport 8080 ct state new \
            add @ratelimit_http { ip saddr limit rate 60/minute burst 120 packets } \
            accept

        # ── Block external access to internal services ──
        iifname $WAN_IF tcp dport $ASHCHAN_PORTS drop
        iifname $WAN_IF tcp dport $INFRA_PORTS   drop

        # ── Allow internal (loopback) service traffic ──
        iif lo tcp dport $ASHCHAN_PORTS accept
        iif lo tcp dport $INFRA_PORTS   accept

        # ── Log & drop the rest ──
        limit rate 5/minute log prefix "nft-drop: " level warn
        counter drop
    }

    chain forward {
        type filter hook forward priority 0; policy drop;
    }

    chain output {
        type filter hook output priority 0; policy accept;
    }
}
NFTEOF
    success "Generated ${outfile}"
}

firewall_generate_iptables() {
    local wan_if="$1"
    local outfile="${FIREWALL_STAGE_DIR}/ashchan-iptables.sh"
    mkdir -p "$FIREWALL_STAGE_DIR"
    cat > "$outfile" <<IPTEOF
#!/usr/bin/env bash
# ashchan-iptables.sh — Ashchan firewall rules (iptables)
set -euo pipefail

IPT="iptables"
IP6T="ip6tables"
WAN_IF="${wan_if}"

# ── Flush ──
\$IPT -F && \$IPT -X
\$IPT -t nat -F && \$IPT -t nat -X
\$IPT -t mangle -F && \$IPT -t mangle -X

# ── Default policy: drop ──
\$IPT -P INPUT DROP
\$IPT -P FORWARD DROP
\$IPT -P OUTPUT ACCEPT

# ── Loopback ──
\$IPT -A INPUT -i lo -j ACCEPT
\$IPT -A OUTPUT -o lo -j ACCEPT

# ── Established / related ──
\$IPT -A INPUT -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
\$IPT -A INPUT -m conntrack --ctstate INVALID -j DROP

# ── ICMP ──
\$IPT -A INPUT -p icmp --icmp-type echo-request -m limit --limit 10/s -j ACCEPT

# ── SSH (rate-limited) ──
\$IPT -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \\
     -m recent --set --name SSH
\$IPT -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW \\
     -m recent --update --seconds 60 --hitcount 5 --name SSH -j DROP
\$IPT -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -j ACCEPT

# ── Anubis public (rate-limited via hashlimit) ──
\$IPT -A INPUT -p tcp --dport 8080 -m conntrack --ctstate NEW \\
     -m hashlimit --hashlimit-upto 60/min --hashlimit-burst 120 \\
     --hashlimit-mode srcip --hashlimit-name http_limit \\
     -j ACCEPT

# ── Block external access to internal services ──
for port in 9501 9502 9503 9504 9505 9506 \\
            8443 8444 8445 8446 8447 8448 \\
            9091 5432 6379 9000 9001; do
    \$IPT -A INPUT -i "\$WAN_IF" -p tcp --dport "\$port" -j DROP
done

# ── SYN flood protection ──
\$IPT -A INPUT -p tcp --syn -m limit --limit 25/s --limit-burst 50 -j ACCEPT
\$IPT -A INPUT -p tcp --syn -j DROP

# ── Log & drop ──
\$IPT -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables-drop: " --log-level 4
\$IPT -A INPUT -j DROP

echo "iptables rules applied"
IPTEOF
    chmod +x "$outfile"
    success "Generated ${outfile}"
}

firewall_generate_firewalld() {
    local outfile="${FIREWALL_STAGE_DIR}/ashchan-firewalld.sh"
    mkdir -p "$FIREWALL_STAGE_DIR"
    cat > "$outfile" <<'FWDEOF'
#!/usr/bin/env bash
# ashchan-firewalld.sh — Ashchan firewall rules (firewalld)
set -euo pipefail

# Set default zone to drop
sudo firewall-cmd --set-default-zone=drop

# Allow SSH
sudo firewall-cmd --permanent --add-service=ssh

# Allow Anubis public port
sudo firewall-cmd --permanent --add-port=8080/tcp

# Allow loopback-only service ports (trusted zone)
sudo firewall-cmd --permanent --zone=trusted --add-interface=lo

# Add internal ports to trusted zone (loopback only)
for port in 9501 9502 9503 9504 9505 9506 \
            8443 8444 8445 8446 8447 8448 \
            9091 5432 6379 9000 9001; do
    sudo firewall-cmd --permanent --zone=trusted --add-port=${port}/tcp
done

# Enable logging of dropped packets
sudo firewall-cmd --permanent --set-log-denied=unicast

# Reload
sudo firewall-cmd --reload
sudo firewall-cmd --list-all

echo "firewalld rules applied"
FWDEOF
    chmod +x "$outfile"
    success "Generated ${outfile}"
}

firewall_generate_pf() {
    local wan_if="$1"
    local outfile="${FIREWALL_STAGE_DIR}/pf.conf"
    mkdir -p "$FIREWALL_STAGE_DIR"
    cat > "$outfile" <<PFEOF
# ── Ashchan pf.conf ─────────────────────────────────────────
# FreeBSD Packet Filter configuration

# ── Macros ──
ext_if = "${wan_if}"
ashchan_ports = "{ 9501:9506, 8443:8448, 9091 }"
infra_ports   = "{ 5432, 6379, 9000, 9001 }"

# ── Tables ──
table <bruteforce>  persist
table <blocklist>   persist file "/etc/pf.blocklist"

# ── Options ──
set skip on lo0
set block-policy drop
set loginterface \$ext_if
set optimization aggressive
set limit { states 100000, frags 25000 }

# ── Normalisation ──
scrub in all fragment reassemble no-df max-mss 1440

# ── Filter rules ──

# Block everything by default
block log all

# Drop known-bad IPs
block drop in  quick on \$ext_if from <blocklist>
block drop in  quick on \$ext_if from <bruteforce>

# Allow outbound
pass out quick on \$ext_if keep state

# Allow ICMP (rate-limited)
pass in on \$ext_if inet proto icmp icmp-type { echoreq, unreach, timex } \\
    keep state (max-src-conn-rate 10/10)

# SSH — brute-force protection via overload table
pass in on \$ext_if proto tcp to port 22 keep state \\
    (max-src-conn 10, max-src-conn-rate 4/60, \\
     overload <bruteforce> flush global)

# Anubis — public HTTP with connection limits
pass in on \$ext_if proto tcp to port 8080 keep state \\
    (max-src-conn 100, max-src-conn-rate 60/60, \\
     overload <bruteforce> flush)

# Block external access to all internal service ports
block drop in on \$ext_if proto tcp to port \$ashchan_ports
block drop in on \$ext_if proto tcp to port \$infra_ports

# Allow all loopback
pass quick on lo0
PFEOF
    success "Generated ${outfile}"
}

firewall_generate_ipfw() {
    local wan_if="$1"
    local outfile="${FIREWALL_STAGE_DIR}/ashchan-ipfw.sh"
    mkdir -p "$FIREWALL_STAGE_DIR"
    cat > "$outfile" <<IPFWEOF
#!/bin/sh
# ashchan-ipfw.sh — Ashchan firewall rules (IPFW)

# Flush existing rules
ipfw -q flush

# Allow loopback
ipfw -q add 100 allow all from any to any via lo0

# Allow established connections
ipfw -q add 200 allow tcp from any to any established

# SSH (rate-limited: 4 connections per 60 seconds per source)
ipfw -q add 300 allow tcp from any to me 22 setup limit src-addr 4

# Anubis public HTTP
ipfw -q add 400 allow tcp from any to me 8080 setup limit src-addr 100

# Block external access to internal service ports
for port in 9501 9502 9503 9504 9505 9506 \\
            8443 8444 8445 8446 8447 8448 \\
            9091 5432 6379 9000 9001; do
    ipfw -q add 500 deny tcp from any to me \${port} in recv ${wan_if}
done

# Allow ICMP
ipfw -q add 600 allow icmp from any to any icmptypes 0,3,8,11

# Allow outbound
ipfw -q add 700 allow all from me to any out

# Default deny
ipfw -q add 65534 deny log all from any to any

echo "ipfw rules applied"
IPFWEOF
    chmod +x "$outfile"
    success "Generated ${outfile}"
}

firewall_generate_fail2ban() {
    local os="$1" backend="$2"
    local f2b_dir="${FIREWALL_STAGE_DIR}/fail2ban"
    local filter_dir="${f2b_dir}/filter.d"
    mkdir -p "$f2b_dir" "$filter_dir"

    # Determine ban action
    local banaction="nftables-multiport"
    case "$backend" in
        iptables)  banaction="iptables-multiport" ;;
        firewalld) banaction="firewallcmd-ipset" ;;
        pf)        banaction="pf" ;;
        ipfw)      banaction="ipfw" ;;
    esac

    cat > "${f2b_dir}/jail.local" <<F2BEOF
[DEFAULT]
bantime  = 3600
findtime = 600
maxretry = 5
banaction = ${banaction}

# ── SSH brute-force ─────────────────────────────────────────
[sshd]
enabled  = true
port     = ssh
filter   = sshd
logpath  = /var/log/auth.log
maxretry = 3
bantime  = 7200
findtime = 300

[sshd-progressive]
enabled  = true
port     = ssh
filter   = sshd
logpath  = /var/log/auth.log
maxretry = 2
bantime  = 86400
findtime = 86400

# ── Anubis / HTTP abuse ────────────────────────────────────
[ashchan-http-flood]
enabled  = true
port     = 8080
filter   = ashchan-http-flood
logpath  = /tmp/ashchan-gateway.log
maxretry = 120
findtime = 60
bantime  = 3600

[ashchan-http-4xx]
enabled  = true
port     = 8080
filter   = ashchan-http-4xx
logpath  = /tmp/ashchan-gateway.log
maxretry = 30
findtime = 300
bantime  = 1800

[ashchan-http-auth]
enabled  = true
port     = 8080
filter   = ashchan-http-auth
logpath  = /tmp/ashchan-auth.log
maxretry = 5
findtime = 300
bantime  = 7200

# ── Spam / rapid posting ───────────────────────────────────
[ashchan-post-flood]
enabled  = true
port     = 8080
filter   = ashchan-post-flood
logpath  = /tmp/ashchan-boards.log
maxretry = 10
findtime = 60
bantime  = 3600

# ── PostgreSQL brute-force ──────────────────────────────────
[postgresql]
enabled  = true
port     = 5432
filter   = ashchan-postgresql
logpath  = /var/log/postgresql/postgresql-*-main.log
maxretry = 3
bantime  = 7200

# ── Redis brute-force ──────────────────────────────────────
[redis]
enabled  = true
port     = 6379
filter   = ashchan-redis
logpath  = /var/log/redis/redis-server.log
maxretry = 3
bantime  = 7200

# ── Recidive (ban repeat offenders across all jails) ────────
[recidive]
enabled  = true
filter   = recidive
logpath  = /var/log/fail2ban.log
maxretry = 3
findtime = 86400
bantime  = 604800
action   = ${banaction}[name=recidive]
F2BEOF
    success "Generated ${f2b_dir}/jail.local"

    # ── Custom filters ──
    cat > "${filter_dir}/ashchan-http-flood.conf" <<'EOF'
[Definition]
failregex = ^\[.*\]\s+<HOST>\s+.*\s+(GET|POST|PUT|DELETE|HEAD|OPTIONS)\s+
ignoreregex =
datepattern = {^LN-BEG}
EOF

    cat > "${filter_dir}/ashchan-http-4xx.conf" <<'EOF'
[Definition]
failregex = ^\[.*\]\s+<HOST>\s+.*\s+HTTP/\d\.\d"\s+4\d\d\s+
ignoreregex =
datepattern = {^LN-BEG}
EOF

    cat > "${filter_dir}/ashchan-http-auth.conf" <<'EOF'
[Definition]
failregex = ^\[.*\]\s+.*"ip":\s*"<HOST>".*"event":\s*"auth_failed"
            ^\[.*\]\s+.*<HOST>.*401\s+
ignoreregex =
datepattern = {^LN-BEG}
EOF

    cat > "${filter_dir}/ashchan-post-flood.conf" <<'EOF'
[Definition]
failregex = ^\[.*\]\s+<HOST>\s+.*POST\s+/api/v1/boards/.*/threads
            ^\[.*\]\s+<HOST>\s+.*POST\s+/api/v1/boards/.*/posts
ignoreregex =
datepattern = {^LN-BEG}
EOF

    cat > "${filter_dir}/ashchan-postgresql.conf" <<'EOF'
[Definition]
failregex = FATAL:\s+password authentication failed for user.*client\s+<HOST>
            FATAL:\s+no pg_hba.conf entry for host\s+"<HOST>"
ignoreregex =
datepattern = {^LN-BEG}
EOF

    cat > "${filter_dir}/ashchan-redis.conf" <<'EOF'
[Definition]
failregex = Client <HOST>:\d+ failed auth
ignoreregex =
EOF

    success "Generated fail2ban filters in ${filter_dir}/"
}

firewall_generate_sysctl() {
    local os="$1"
    mkdir -p "$FIREWALL_STAGE_DIR"

    if [[ "$os" == "freebsd" ]]; then
        local outfile="${FIREWALL_STAGE_DIR}/sysctl-ashchan.conf"
        cat > "$outfile" <<'EOF'
# ── Network hardening ──
net.inet.tcp.blackhole=2
net.inet.udp.blackhole=1
net.inet.icmp.icmplim=50
net.inet.tcp.syncookies=1
net.inet.tcp.always_keepalive=1
net.inet.tcp.rfc1323=1
net.inet.tcp.path_mtu_discovery=1
net.inet.ip.redirect=0
net.inet.ip.sourceroute=0
net.inet.ip.accept_sourceroute=0

# ── Performance ──
kern.ipc.somaxconn=65535
kern.ipc.maxsockets=204800
net.inet.tcp.sendspace=65536
net.inet.tcp.recvspace=65536
kern.maxfiles=204800
kern.maxfilesperproc=102400
EOF
        success "Generated ${outfile}"
    else
        local outfile="${FIREWALL_STAGE_DIR}/99-ashchan.conf"
        cat > "$outfile" <<'EOF'
# ── Network stack hardening ──────────────────────────────────

# Ignore ICMP redirects (prevent MITM)
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv6.conf.all.accept_redirects = 0
net.ipv6.conf.default.accept_redirects = 0
net.ipv4.conf.all.send_redirects = 0

# Ignore source-routed packets
net.ipv4.conf.all.accept_source_route = 0
net.ipv6.conf.all.accept_source_route = 0

# Enable reverse path filtering (anti-spoofing)
net.ipv4.conf.all.rp_filter = 1
net.ipv4.conf.default.rp_filter = 1

# SYN flood protection
net.ipv4.tcp_syncookies = 1
net.ipv4.tcp_max_syn_backlog = 4096
net.ipv4.tcp_synack_retries = 2

# Disable IP forwarding (unless acting as router)
net.ipv4.ip_forward = 0
net.ipv6.conf.all.forwarding = 0

# Ignore ICMP broadcasts (smurf protection)
net.ipv4.icmp_echo_ignore_broadcasts = 1

# Log martians (spoofed/impossible addresses)
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1

# ── Performance tuning for high-connection servers ───────────

# Increase connection tracking table
net.netfilter.nf_conntrack_max = 1048576
net.netfilter.nf_conntrack_tcp_timeout_established = 3600

# Increase local port range
net.ipv4.ip_local_port_range = 10000 65535

# Reuse TIME_WAIT sockets
net.ipv4.tcp_tw_reuse = 1

# Faster TCP keepalives (detect dead connections)
net.ipv4.tcp_keepalive_time = 600
net.ipv4.tcp_keepalive_intvl = 30
net.ipv4.tcp_keepalive_probes = 5

# Increase socket buffer sizes (Swoole benefits)
net.core.rmem_max = 16777216
net.core.wmem_max = 16777216
net.core.rmem_default = 1048576
net.core.wmem_default = 1048576
net.ipv4.tcp_rmem = 4096 1048576 16777216
net.ipv4.tcp_wmem = 4096 1048576 16777216

# Increase somaxconn for Swoole listeners
net.core.somaxconn = 65535
net.core.netdev_max_backlog = 65535

# ── File descriptor limits ───────────────────────────────────
fs.file-max = 2097152
EOF
        success "Generated ${outfile}"
    fi
}

firewall_install_configs() {
    local os="$1" backend="$2"

    info "Installing generated configs to system paths (requires sudo)..."
    echo

    # ── Firewall rules ──
    case "$backend" in
        nftables)
            if [[ -f "${FIREWALL_STAGE_DIR}/nftables.conf" ]]; then
                sudo cp "${FIREWALL_STAGE_DIR}/nftables.conf" /etc/nftables.conf
                if sudo nft -c -f /etc/nftables.conf &>/dev/null; then
                    sudo nft -f /etc/nftables.conf
                    sudo systemctl enable nftables 2>/dev/null || true
                    success "nftables rules installed and applied"
                else
                    fail "nftables syntax check failed — rules not applied"
                fi
            fi
            ;;
        iptables)
            if [[ -f "${FIREWALL_STAGE_DIR}/ashchan-iptables.sh" ]]; then
                sudo cp "${FIREWALL_STAGE_DIR}/ashchan-iptables.sh" /etc/ashchan-iptables.sh
                if sudo bash /etc/ashchan-iptables.sh; then
                    success "iptables rules installed and applied"
                    # Try to persist
                    if command -v netfilter-persistent &>/dev/null; then
                        sudo netfilter-persistent save 2>/dev/null && success "Rules persisted (netfilter-persistent)"
                    elif [[ -d /etc/sysconfig ]]; then
                        sudo iptables-save > /etc/sysconfig/iptables 2>/dev/null && success "Rules persisted (sysconfig)"
                    else
                        warn "Install iptables-persistent to persist rules across reboots"
                    fi
                else
                    fail "iptables script failed"
                fi
            fi
            ;;
        firewalld)
            if [[ -f "${FIREWALL_STAGE_DIR}/ashchan-firewalld.sh" ]]; then
                if sudo bash "${FIREWALL_STAGE_DIR}/ashchan-firewalld.sh"; then
                    success "firewalld rules applied"
                else
                    fail "firewalld configuration failed"
                fi
            fi
            ;;
        pf)
            if [[ -f "${FIREWALL_STAGE_DIR}/pf.conf" ]]; then
                sudo cp "${FIREWALL_STAGE_DIR}/pf.conf" /etc/pf.conf
                if sudo pfctl -nf /etc/pf.conf &>/dev/null; then
                    sudo pfctl -f /etc/pf.conf
                    sudo sysrc pf_enable=YES 2>/dev/null || true
                    success "pf rules installed and loaded"
                else
                    fail "pf syntax check failed — rules not loaded"
                fi
            fi
            ;;
        ipfw)
            if [[ -f "${FIREWALL_STAGE_DIR}/ashchan-ipfw.sh" ]]; then
                sudo cp "${FIREWALL_STAGE_DIR}/ashchan-ipfw.sh" /etc/ipfw.rules
                if sudo sh /etc/ipfw.rules; then
                    sudo sysrc firewall_enable=YES firewall_type=/etc/ipfw.rules firewall_logging=YES 2>/dev/null || true
                    success "ipfw rules installed and applied"
                else
                    fail "ipfw script failed"
                fi
            fi
            ;;
    esac

    # ── fail2ban ──
    if [[ -d "${FIREWALL_STAGE_DIR}/fail2ban" ]]; then
        if command -v fail2ban-client &>/dev/null; then
            sudo cp "${FIREWALL_STAGE_DIR}/fail2ban/jail.local" /etc/fail2ban/jail.local
            sudo cp "${FIREWALL_STAGE_DIR}/fail2ban/filter.d/"* /etc/fail2ban/filter.d/ 2>/dev/null || true
            sudo systemctl restart fail2ban 2>/dev/null || sudo service fail2ban restart 2>/dev/null || true
            success "fail2ban configuration installed"
        else
            warn "fail2ban not installed — configs generated but not deployed"
            info "Install fail2ban, then copy configs:"
            info "  sudo cp ${FIREWALL_STAGE_DIR}/fail2ban/jail.local /etc/fail2ban/jail.local"
            info "  sudo cp ${FIREWALL_STAGE_DIR}/fail2ban/filter.d/* /etc/fail2ban/filter.d/"
        fi
    fi

    # ── sysctl ──
    if [[ "$os" == "freebsd" ]] && [[ -f "${FIREWALL_STAGE_DIR}/sysctl-ashchan.conf" ]]; then
        info "Append sysctl tuning to /etc/sysctl.conf manually:"
        info "  cat ${FIREWALL_STAGE_DIR}/sysctl-ashchan.conf >> /etc/sysctl.conf"
    elif [[ -f "${FIREWALL_STAGE_DIR}/99-ashchan.conf" ]]; then
        if [[ -d /etc/sysctl.d ]]; then
            sudo cp "${FIREWALL_STAGE_DIR}/99-ashchan.conf" /etc/sysctl.d/99-ashchan.conf
            sudo sysctl -p /etc/sysctl.d/99-ashchan.conf 2>/dev/null && success "sysctl hardening applied" || warn "Some sysctl settings may not apply in containers"
        else
            warn "No /etc/sysctl.d — append manually:"
            info "  cat ${FIREWALL_STAGE_DIR}/99-ashchan.conf >> /etc/sysctl.conf && sysctl -p"
        fi
    fi
}

cmd_firewall_setup() {
    banner "Firewall Hardening"

    local os backend wan_if
    os=$(detect_os)
    backend=$(detect_firewall_backend)
    wan_if=$(detect_wan_interface)

    step "System detection"
    success "OS: ${os}"
    success "Firewall backend: ${backend}"
    success "WAN interface: ${wan_if}"

    if [[ "$backend" == "none" ]]; then
        fail "No supported firewall backend found"
        info "Install one of: nftables, iptables, firewalld (Linux) or pf, ipfw (FreeBSD)"
        return 1
    fi

    echo
    echo -e "  ${BOLD}This will configure:${NC}"
    echo -e "    1. ${backend} firewall rules (only SSH + Anubis exposed)"
    echo -e "    2. fail2ban intrusion prevention (SSH, HTTP, spam, DB)"
    echo -e "    3. sysctl kernel/network hardening"
    echo
    echo -e "  ${DIM}All configs are generated to ${FIREWALL_STAGE_DIR}/${NC}"
    echo -e "  ${DIM}See docs/FIREWALL_HARDENING.md for full reference${NC}"
    echo

    if ! confirm "Generate firewall configuration?"; then
        info "Skipped"
        return 0
    fi

    # Allow interface override
    echo -en "  ${Y}?${NC} WAN interface [${wan_if}]: "
    read -r custom_if
    [[ -n "$custom_if" ]] && wan_if="$custom_if"

    step "Generating configurations"

    # Generate firewall rules for detected backend
    case "$backend" in
        nftables)  firewall_generate_nftables  "$wan_if" ;;
        iptables)  firewall_generate_iptables  "$wan_if" ;;
        firewalld) firewall_generate_firewalld ;;
        pf)        firewall_generate_pf  "$wan_if" ;;
        ipfw)      firewall_generate_ipfw "$wan_if" ;;
    esac

    # fail2ban
    firewall_generate_fail2ban "$os" "$backend"

    # sysctl
    firewall_generate_sysctl "$os"

    echo
    success "All configs generated in ${FIREWALL_STAGE_DIR}/"
    echo

    echo -e "  ${BOLD}Generated files:${NC}"
    separator
    find "$FIREWALL_STAGE_DIR" -type f | sort | while read -r f; do
        echo "  ${f}"
    done
    echo

    if confirm "Install configs to system paths now? (requires sudo)"; then
        firewall_install_configs "$os" "$backend"
        echo
        success "Firewall hardening complete"
        echo
        echo -e "  ${BOLD}Verify with:${NC}"
        separator
        case "$backend" in
            nftables)  echo "  sudo nft list ruleset" ;;
            iptables)  echo "  sudo iptables -L -n" ;;
            firewalld) echo "  sudo firewall-cmd --list-all" ;;
            pf)        echo "  sudo pfctl -sr" ;;
            ipfw)      echo "  sudo ipfw list" ;;
        esac
        echo "  sudo fail2ban-client status"
        echo "  nmap -Pn -sT -p 22,8080,5432,6379,9000,9501-9506,8443-8448 localhost"
        echo
    else
        info "Configs saved to ${FIREWALL_STAGE_DIR}/ — install manually when ready"
        echo
        echo -e "  ${BOLD}Manual install:${NC}"
        separator
        case "$backend" in
            nftables)  echo "  sudo cp ${FIREWALL_STAGE_DIR}/nftables.conf /etc/nftables.conf" ;;
            iptables)  echo "  sudo bash ${FIREWALL_STAGE_DIR}/ashchan-iptables.sh" ;;
            firewalld) echo "  sudo bash ${FIREWALL_STAGE_DIR}/ashchan-firewalld.sh" ;;
            pf)        echo "  sudo cp ${FIREWALL_STAGE_DIR}/pf.conf /etc/pf.conf && sudo pfctl -f /etc/pf.conf" ;;
            ipfw)      echo "  sudo cp ${FIREWALL_STAGE_DIR}/ashchan-ipfw.sh /etc/ipfw.rules && sudo sh /etc/ipfw.rules" ;;
        esac
        echo "  sudo cp ${FIREWALL_STAGE_DIR}/fail2ban/jail.local /etc/fail2ban/jail.local"
        echo "  sudo cp ${FIREWALL_STAGE_DIR}/fail2ban/filter.d/* /etc/fail2ban/filter.d/"
        if [[ "$os" == "linux" ]]; then
            echo "  sudo cp ${FIREWALL_STAGE_DIR}/99-ashchan.conf /etc/sysctl.d/99-ashchan.conf"
            echo "  sudo sysctl -p /etc/sysctl.d/99-ashchan.conf"
        fi
        echo
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Nginx reverse proxy
# ─────────────────────────────────────────────────────────────────────────────

NGINX_CONF_SRC="${SCRIPT_DIR}/config/nginx/nginx.conf"
NGINX_CONF_DST="/etc/nginx/nginx.conf"
CLOUDFLARE_ORIGIN_CA_URL="https://developers.cloudflare.com/ssl/static/authenticated_origin_pull_ca.pem"
CLOUDFLARE_CERT_DIR="/etc/nginx/certs"
CLOUDFLARE_CERT_PATH="${CLOUDFLARE_CERT_DIR}/cloudflare-origin.pem"

check_nginx() {
    if command -v nginx &>/dev/null; then
        local ver
        ver=$(nginx -v 2>&1 | grep -oP '[\d.]+' | head -1)
        success "nginx ${ver}"
        return 0
    else
        warn "nginx not found"
        return 1
    fi
}

nginx_is_running() {
    if pidof nginx &>/dev/null || (command -v systemctl &>/dev/null && systemctl is-active nginx &>/dev/null); then
        return 0
    fi
    return 1
}

nginx_health() {
    if curl -sk --max-time 2 "https://localhost/health" &>/dev/null || \
       curl -s  --max-time 2 "http://localhost/health" &>/dev/null; then
        return 0
    fi
    return 1
}

nginx_start() {
    if nginx_is_running; then
        info "nginx already running"
        return 0
    fi
    if ! command -v nginx &>/dev/null; then
        warn "nginx not installed — skipping"
        return 1
    fi
    sudo systemctl start nginx 2>/dev/null || sudo nginx 2>/dev/null || {
        fail "Could not start nginx"
        return 1
    }
    success "nginx started"
}

nginx_stop() {
    if nginx_is_running; then
        sudo systemctl stop nginx 2>/dev/null || sudo nginx -s stop 2>/dev/null || true
        success "nginx stopped"
    else
        info "nginx not running"
    fi
}

nginx_reload() {
    if nginx_is_running; then
        if sudo nginx -t &>/dev/null; then
            sudo systemctl reload nginx 2>/dev/null || sudo nginx -s reload 2>/dev/null
            success "nginx reloaded"
        else
            fail "nginx config test failed — not reloading"
            sudo nginx -t 2>&1 | tail -5
            return 1
        fi
    else
        warn "nginx not running — start it first"
    fi
}

cmd_nginx_setup() {
    banner "Nginx Reverse Proxy Setup"

    step "Checking nginx"
    if ! check_nginx; then
        info "Install nginx first:"
        local os
        os=$(detect_os)
        if [[ "$os" == "freebsd" ]]; then
            info "  sudo pkg install nginx"
        else
            info "  sudo apt-get install -y nginx   # Debian/Ubuntu"
            info "  sudo dnf install -y nginx        # RHEL/Fedora"
            info "  sudo apk add nginx               # Alpine"
        fi
        echo
        if ! confirm "Continue anyway? (config will be generated but not applied)"; then
            info "Aborted"
            return 0
        fi
    fi

    step "Configuration"
    if [[ ! -f "$NGINX_CONF_SRC" ]]; then
        die "Reference nginx config not found: ${NGINX_CONF_SRC}"
    fi

    # Ask for domain
    local domain="ashchan.example.com"
    echo -en "  ${Y}?${NC} Server domain [${domain}]: "
    read -r custom_domain
    [[ -n "$custom_domain" ]] && domain="$custom_domain"

    # Ask for TLS cert paths
    local cert_path="/etc/letsencrypt/live/${domain}/fullchain.pem"
    local key_path="/etc/letsencrypt/live/${domain}/privkey.pem"
    echo -en "  ${Y}?${NC} SSL certificate path [${cert_path}]: "
    read -r custom_cert
    [[ -n "$custom_cert" ]] && cert_path="$custom_cert"
    echo -en "  ${Y}?${NC} SSL key path [${key_path}]: "
    read -r custom_key
    [[ -n "$custom_key" ]] && key_path="$custom_key"

    # Generate customised config
    local staged="${SCRIPT_DIR}/config/nginx/nginx-staged.conf"
    sed -e "s|ashchan.example.com|${domain}|g" \
        -e "s|/etc/letsencrypt/live/ashchan.example.com/fullchain.pem|${cert_path}|g" \
        -e "s|/etc/letsencrypt/live/ashchan.example.com/privkey.pem|${key_path}|g" \
        "$NGINX_CONF_SRC" > "$staged"
    success "Generated ${staged}"
    info "Domain: ${domain}"
    info "Certificate: ${cert_path}"
    info "Key: ${key_path}"

    step "Anubis real-IP configuration"
    info "When behind nginx, Anubis must use X-Forwarded-For for client IPs"
    local anubis_env="${ANUBIS_DIR}/env"
    if [[ -f "$anubis_env" ]]; then
        if grep -q 'USE_REMOTE_ADDRESS=true' "$anubis_env" 2>/dev/null; then
            sed -i 's/USE_REMOTE_ADDRESS=true/USE_REMOTE_ADDRESS=false/' "$anubis_env"
            success "Set USE_REMOTE_ADDRESS=false in Anubis env"
        else
            info "USE_REMOTE_ADDRESS already configured"
        fi
        if ! grep -q 'CUSTOM_REAL_IP_HEADER' "$anubis_env" 2>/dev/null; then
            echo 'CUSTOM_REAL_IP_HEADER=X-Forwarded-For' >> "$anubis_env"
            success "Added CUSTOM_REAL_IP_HEADER=X-Forwarded-For to Anubis env"
        elif grep -q '# .*CUSTOM_REAL_IP_HEADER' "$anubis_env" 2>/dev/null && \
             ! grep -q '^CUSTOM_REAL_IP_HEADER' "$anubis_env" 2>/dev/null; then
            echo 'CUSTOM_REAL_IP_HEADER=X-Forwarded-For' >> "$anubis_env"
            success "Added CUSTOM_REAL_IP_HEADER=X-Forwarded-For to Anubis env"
        else
            info "CUSTOM_REAL_IP_HEADER already set"
        fi
    else
        warn "Anubis env file not found at ${anubis_env}"
        info "When deploying, set USE_REMOTE_ADDRESS=false and CUSTOM_REAL_IP_HEADER=X-Forwarded-For"
    fi

    echo
    if command -v nginx &>/dev/null; then
        if confirm "Install config to ${NGINX_CONF_DST}? (requires sudo)"; then
            # Backup existing config
            if [[ -f "$NGINX_CONF_DST" ]]; then
                local backup="${NGINX_CONF_DST}.bak.$(date +%Y%m%d_%H%M%S)"
                sudo cp "$NGINX_CONF_DST" "$backup"
                success "Backed up existing config to ${backup}"
            fi

            sudo cp "$staged" "$NGINX_CONF_DST"

            # Ensure required directories exist
            sudo mkdir -p /var/lib/nginx/body /var/lib/nginx/proxy /var/www/certbot 2>/dev/null || true

            if sudo nginx -t 2>/dev/null; then
                success "nginx config test passed"
                if nginx_is_running; then
                    sudo systemctl reload nginx 2>/dev/null || sudo nginx -s reload 2>/dev/null
                    success "nginx reloaded with new config"
                else
                    if confirm "Start nginx now?"; then
                        nginx_start
                    fi
                fi
            else
                fail "nginx config test failed — check certificate/key paths"
                sudo nginx -t 2>&1 | tail -5
                info "Fix the issues and run: sudo nginx -t && sudo systemctl reload nginx"
            fi
        else
            info "Config saved to ${staged}"
            info "Install manually: sudo cp ${staged} ${NGINX_CONF_DST}"
        fi
    else
        info "Config saved to ${staged}"
        info "Install nginx, then: sudo cp ${staged} ${NGINX_CONF_DST}"
    fi

    echo
    echo -e "  ${BOLD}Architecture:${NC}"
    separator
    echo "  nginx (80/443) → Anubis (8080) → API Gateway (9501)"
    echo
    echo -e "  ${BOLD}Next steps:${NC}"
    separator
    echo "  1. Obtain TLS certificate:  sudo certbot --nginx -d ${domain}"
    echo "  2. Generate DH params:      sudo openssl dhparam -out /etc/nginx/dhparam.pem 2048"
    echo "  3. Cloudflare setup:         ./ashchan nginx:cloudflare"
    echo "  4. Update firewall:          ./ashchan firewall:setup"
    echo "  5. Test:                     curl -I https://${domain}"
    echo
    echo -e "  ${DIM}See docs/NGINX_HARDENING.md for full guidance${NC}"
    echo
}

# ─────────────────────────────────────────────────────────────────────────────
# Cloudflare integration
# ─────────────────────────────────────────────────────────────────────────────

# Download Cloudflare's Authenticated Origin Pull CA and update the nginx
# config to enable ssl_verify_client.  Also refreshes the set_real_ip_from
# ranges from Cloudflare's live IP list.
#
# WHY THIS MATTERS:
# 1. Authenticated Origin Pulls — Cloudflare signs every request with a client
#    certificate from their Origin Pull CA.  With ssl_verify_client on, nginx
#    rejects any request NOT from Cloudflare.  This closes the "origin IP leak"
#    attack vector: even if someone discovers your server's real IP, they cannot
#    bypass Cloudflare's WAF, DDoS mitigation, or rate limiting.
# 2. Real IP Restoration — Without set_real_ip_from, $remote_addr is a
#    Cloudflare edge IP.  Rate-limit zones, fail2ban, and admin audit logs
#    would all see CF edge IPs instead of real visitors.  The admin interface
#    needs the true IP to ban/review users and to comply with legal requests.

cmd_nginx_cloudflare() {
    banner "Cloudflare Integration"

    # ── Step 1: Download Origin Pull CA ──────────────────────
    step "Downloading Cloudflare Authenticated Origin Pull CA"
    sudo mkdir -p "$CLOUDFLARE_CERT_DIR"

    if curl -fsSL "$CLOUDFLARE_ORIGIN_CA_URL" -o /tmp/cloudflare-origin.pem 2>/dev/null; then
        # Basic sanity: must contain a PEM certificate
        if grep -q 'BEGIN CERTIFICATE' /tmp/cloudflare-origin.pem; then
            sudo cp /tmp/cloudflare-origin.pem "$CLOUDFLARE_CERT_PATH"
            sudo chmod 644 "$CLOUDFLARE_CERT_PATH"
            rm -f /tmp/cloudflare-origin.pem
            success "Saved ${CLOUDFLARE_CERT_PATH}"
        else
            fail "Downloaded file is not a valid PEM certificate"
            rm -f /tmp/cloudflare-origin.pem
            return 1
        fi
    else
        fail "Could not download Cloudflare Origin Pull CA"
        info "URL: ${CLOUDFLARE_ORIGIN_CA_URL}"
        info "Download manually and save to ${CLOUDFLARE_CERT_PATH}"
        return 1
    fi

    # ── Step 2: Enable ssl_verify_client in config ───────────
    step "Enabling Authenticated Origin Pulls in nginx config"
    local conf="${NGINX_CONF_DST}"
    [[ ! -f "$conf" ]] && conf="${SCRIPT_DIR}/config/nginx/nginx.conf"

    if grep -q '# ssl_client_certificate.*cloudflare' "$conf" 2>/dev/null; then
        # Uncomment the two lines
        sudo sed -i \
            -e 's|# ssl_client_certificate /etc/nginx/certs/cloudflare-origin.pem;|ssl_client_certificate /etc/nginx/certs/cloudflare-origin.pem;|' \
            -e 's|# ssl_verify_client on;|ssl_verify_client on;|' \
            "$conf"
        success "Uncommented ssl_client_certificate + ssl_verify_client"
    elif grep -q 'ssl_client_certificate.*cloudflare' "$conf" 2>/dev/null; then
        info "Authenticated Origin Pulls already enabled"
    else
        warn "Could not find Cloudflare placeholder in config"
        info "Add these lines manually inside the server { ssl } block:"
        info "  ssl_client_certificate ${CLOUDFLARE_CERT_PATH};"
        info "  ssl_verify_client on;"
    fi

    # ── Step 3: Refresh Cloudflare IP ranges ─────────────────
    nginx_update_cf_ips "$conf"

    # ── Step 4: Test & reload ────────────────────────────────
    if nginx_is_running; then
        step "Testing nginx config"
        if sudo nginx -t 2>/dev/null; then
            success "Config test passed"
            if confirm "Reload nginx now?"; then
                sudo systemctl reload nginx 2>/dev/null || sudo nginx -s reload 2>/dev/null
                success "nginx reloaded"
            fi
        else
            fail "nginx config test failed:"
            sudo nginx -t 2>&1 | tail -5
        fi
    fi

    echo
    echo -e "  ${BOLD}Cloudflare checklist:${NC}"
    separator
    echo "  [✓] Cloudflare Origin Pull CA installed"
    echo "  [✓] ssl_verify_client enabled in nginx"
    echo "  [✓] Cloudflare IP ranges set for real IP restoration"
    echo
    echo "  Remaining steps:"
    echo "  1. Cloudflare dashboard → SSL/TLS → Origin Server"
    echo "     → Enable 'Authenticated Origin Pulls'"
    echo "  2. Cloudflare dashboard → SSL/TLS → Overview"
    echo "     → Set mode to 'Full (strict)'"
    echo "  3. Verify:  curl -I https://your-domain.com"
    echo "     (direct-to-origin should now return 400 Bad Request)"
    echo
    echo -e "  ${DIM}See docs/NGINX_HARDENING.md § Cloudflare for details${NC}"
    echo
}

# Update the set_real_ip_from directives in an nginx config with the
# latest Cloudflare IPv4/IPv6 ranges fetched from their API.
nginx_update_cf_ips() {
    local conf="${1:-$NGINX_CONF_DST}"
    [[ ! -f "$conf" ]] && conf="${SCRIPT_DIR}/config/nginx/nginx.conf"

    step "Fetching current Cloudflare IP ranges"

    local ipv4 ipv6
    ipv4=$(curl -fsSL "https://www.cloudflare.com/ips-v4" 2>/dev/null)
    ipv6=$(curl -fsSL "https://www.cloudflare.com/ips-v6" 2>/dev/null)

    if [[ -z "$ipv4" ]]; then
        warn "Could not fetch Cloudflare IPv4 ranges — keeping existing list"
        return 1
    fi

    # Count how many ranges we got
    local v4_count v6_count
    v4_count=$(echo "$ipv4" | wc -l)
    v6_count=$(echo "$ipv6" | wc -l)
    info "Fetched ${v4_count} IPv4 and ${v6_count} IPv6 ranges"

    # Build the replacement block
    local new_block=""
    new_block+="    # ── Cloudflare IPv4 ranges ──\n"
    while IFS= read -r cidr; do
        [[ -n "$cidr" ]] && new_block+="    set_real_ip_from ${cidr};\n"
    done <<< "$ipv4"
    new_block+="    # ── Cloudflare IPv6 ranges ──\n"
    while IFS= read -r cidr; do
        [[ -n "$cidr" ]] && new_block+="    set_real_ip_from ${cidr};\n"
    done <<< "$ipv6"
    new_block+="    # ── Use CF-Connecting-IP as the source of truth ──\n"
    new_block+="    real_ip_header    CF-Connecting-IP;\n"
    new_block+="    real_ip_recursive on;"

    # Replace the block between markers in the config
    # Markers: "# ── Cloudflare IPv4 ranges ──" to "real_ip_recursive on;"
    if grep -q 'Cloudflare IPv4 ranges' "$conf" 2>/dev/null; then
        # Use awk to replace the block
        local tmp_conf
        tmp_conf=$(mktemp)
        awk -v replacement="$(echo -e "$new_block")" '
        /# ── Cloudflare IPv4 ranges/ { skip=1; printed=0 }
        skip && /real_ip_recursive on;/ { print replacement; skip=0; printed=1; next }
        skip { next }
        { print }
        ' "$conf" > "$tmp_conf"

        if [[ -s "$tmp_conf" ]]; then
            sudo cp "$tmp_conf" "$conf"
            rm -f "$tmp_conf"
            success "Updated Cloudflare IP ranges in ${conf}"
        else
            rm -f "$tmp_conf"
            warn "Replacement produced empty file — keeping original"
        fi
    else
        warn "Cloudflare IP range markers not found in ${conf}"
        info "Add the ranges manually — see docs/NGINX_HARDENING.md"
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Cleanup
# ─────────────────────────────────────────────────────────────────────────────

cmd_clean() {
    step "Cleaning runtime artifacts"
    rm -rf "$PID_DIR"
    rm -f /tmp/ashchan-*.log
    for svc in "${SVC_NAMES[@]}"; do
        rm -rf "${SCRIPT_DIR}/services/${SVC_DIRS[$svc]}/runtime" 2>/dev/null || true
    done
    success "Cleaned PID files, logs, and runtime caches"
}

# ─────────────────────────────────────────────────────────────────────────────
# Status display
# ─────────────────────────────────────────────────────────────────────────────

cmd_status() {
    step "Service status"
    printf "  ${BOLD}%-20s %-8s %-8s %-10s${NC}\n" "SERVICE" "PORT" "PID" "HEALTH"
    separator
    for svc in "${SVC_NAMES[@]}"; do
        local pid_str="-" health_str="-" health_color="$DIM"
        if svc_is_running "$svc"; then
            pid_str="$(svc_pid "$svc")"
            if svc_health "$svc"; then
                health_str="healthy"
                health_color="$G"
            else
                health_str="unhealthy"
                health_color="$Y"
            fi
        else
            health_str="stopped"
            health_color="$DIM"
        fi
        printf "  %-20s %-8s %-8s ${health_color}%-10s${NC}\n" \
            "${SVC_LABELS[$svc]}" "${SVC_PORTS[$svc]}" "$pid_str" "$health_str"
    done
    echo

    # Anubis
    echo
    printf "  ${BOLD}%-20s %-8s %-8s %-10s${NC}\n" "FIREWALL" "PORT" "PID" "HEALTH"
    separator
    local anubis_pid_str="-" anubis_health_str="-" anubis_color="$DIM"
    if anubis_is_running; then
        anubis_pid_str="$(anubis_pid)"
        if anubis_health; then
            anubis_health_str="healthy"
            anubis_color="$G"
        else
            anubis_health_str="unhealthy"
            anubis_color="$Y"
        fi
    else
        anubis_health_str="stopped"
        anubis_color="$DIM"
    fi
    printf "  %-20s %-8s %-8s ${anubis_color}%-10s${NC}\n" \
        "Anubis (AI Firewall)" "${ANUBIS_PORT}" "$anubis_pid_str" "$anubis_health_str"

    # Nginx
    local nginx_pid_str="-" nginx_health_str="-" nginx_color="$DIM"
    if nginx_is_running; then
        nginx_pid_str="$(pidof nginx 2>/dev/null | awk '{print $1}' || echo '-')"
        if nginx_health; then
            nginx_health_str="healthy"
            nginx_color="$G"
        else
            nginx_health_str="unhealthy"
            nginx_color="$Y"
        fi
    else
        nginx_health_str="stopped"
        nginx_color="$DIM"
    fi
    printf "  %-20s %-8s %-8s ${nginx_color}%-10s${NC}\n" \
        "nginx (Rev. Proxy)" "80/443" "$nginx_pid_str" "$nginx_health_str"
    echo

    # Infrastructure
    printf "  ${BOLD}%-20s %-8s${NC}\n" "INFRASTRUCTURE" "STATUS"
    separator
    local pg_status="down" redis_status="down"
    if check_db &>/dev/null; then pg_status="${G}up${NC}"; else pg_status="${R}down${NC}"; fi
    if check_redis &>/dev/null; then redis_status="${G}up${NC}"; else redis_status="${R}down${NC}"; fi
    printf "  %-20s " "PostgreSQL"; echo -e "$pg_status"
    printf "  %-20s " "Redis"; echo -e "$redis_status"
    echo
}

# ─────────────────────────────────────────────────────────────────────────────
# Logs
# ─────────────────────────────────────────────────────────────────────────────

cmd_logs() {
    local target="${1:-all}"
    if [[ "$target" == "all" ]]; then
        echo -e "  ${DIM}Tailing all service logs (Ctrl+C to stop)${NC}"
        echo
        tail -f /tmp/ashchan-*.log 2>/dev/null || warn "No log files. Start services first."
    else
        local logfile="/tmp/ashchan-${target}.log"
        if [[ -f "$logfile" ]]; then
            tail -f "$logfile"
        else
            warn "No log file for '${target}'"
        fi
    fi
}

# ─────────────────────────────────────────────────────────────────────────────
# Static binary builds
# ─────────────────────────────────────────────────────────────────────────────

cmd_build() {
    local target="${1:-all}"
    if [[ ! -f "$BUILD_SCRIPT" ]]; then
        die "Build script not found: ${BUILD_SCRIPT}"
    fi

    case "$target" in
        all)
            step "Building all static binaries"
            info "This downloads static-php-cli and compiles PHP + all services"
            info "First run may take 15-30 minutes depending on hardware"
            echo
            bash "$BUILD_SCRIPT"
            echo
            success "Static binaries available in build/static-php/dist/"
            echo
            echo -e "  ${BOLD}Deploy with:${NC}"
            separator
            echo "  scp build/static-php/dist/ashchan-* user@server:/opt/ashchan/"
            echo "  cp build/static-php/ashchan-static@.service /etc/systemd/system/"
            echo "  systemctl enable --now ashchan-static@gateway"
            echo
            ;;
        php)
            step "Building static PHP runtime only"
            bash "$BUILD_SCRIPT" --php-only
            ;;
        clean)
            step "Cleaning static build artifacts"
            bash "$BUILD_SCRIPT" --clean
            success "Static build artifacts removed"
            ;;
        *)
            if [[ -n "${SVC_DIRS[$target]+x}" ]]; then
                step "Building static binary: ${SVC_LABELS[$target]}"
                bash "$BUILD_SCRIPT" "$target"
                success "Built: build/static-php/dist/ashchan-${target}"
            else
                die "Unknown build target: ${target}. Available: all php clean ${SVC_NAMES[*]}"
            fi
            ;;
    esac
}

# ─────────────────────────────────────────────────────────────────────────────
# Full install
# ─────────────────────────────────────────────────────────────────────────────

cmd_install() {
    banner "Full Installation"

    # ─── 0. Auto-install system packages ───
    step "0/10  Installing system requirements"
    install_prerequisites

    # ─── 1. Prerequisites ───
    step "1/10  Checking prerequisites"
    check_php
    check_php_extensions || true
    check_composer
    check_openssl

    # ─── 2. mTLS ───
    step "2/10  Setting up mTLS certificates"
    certs_init_ca
    certs_generate_all

    # ─── 3. Environment ───
    step "3/10  Configuring environment"
    setup_env_files

    # ─── 4. Dependencies ───
    step "4/10  Compiling services"
    compile_services

    # ─── 5. Static binaries (optional) ───
    step "5/10  Static binary build (optional)"
    if [[ -f "$BUILD_SCRIPT" ]]; then
        info "Static builds produce single-file executables for deployment"
        info "This step is optional — services work fine without it"
        echo
        if confirm "Build static binaries? (takes 15-30 min on first run)"; then
            echo
            cmd_build all
        else
            info "Skipped — run later with:  ./ashchan build"
        fi
    else
        info "Build script not found — skipping static builds"
    fi

    # ─── 6. Database ───
    step "6/10  Database setup"
    if check_db 2>/dev/null; then
        cmd_db_install
        cmd_db_seed
    elif provision_postgres; then
        cmd_db_install
        cmd_db_seed
    else
        warn "Skipping DB setup — PostgreSQL not reachable"
        info "Install PostgreSQL, then run:  ./ashchan db:install && ./ashchan db:seed"
    fi

    # ─── 7. Firewall hardening (optional) ───
    step "7/10  Firewall hardening (optional)"
    local fw_backend
    fw_backend=$(detect_firewall_backend)
    if [[ "$fw_backend" != "none" ]]; then
        local fw_os fw_wan
        fw_os=$(detect_os)
        fw_wan=$(detect_wan_interface)
        info "Detected: ${fw_backend} on ${fw_os} (interface: ${fw_wan})"
        info "This configures firewall rules, fail2ban, and sysctl hardening"
        info "Only SSH (22) and HTTP/HTTPS (80/443 or 8080) will be exposed publicly"
        echo
        if confirm "Configure firewall hardening?"; then
            echo -en "  ${Y}?${NC} WAN interface [${fw_wan}]: "
            read -r custom_wan
            [[ -n "$custom_wan" ]] && fw_wan="$custom_wan"

            # Generate configs
            case "$fw_backend" in
                nftables)  firewall_generate_nftables  "$fw_wan" ;;
                iptables)  firewall_generate_iptables  "$fw_wan" ;;
                firewalld) firewall_generate_firewalld ;;
                pf)        firewall_generate_pf  "$fw_wan" ;;
                ipfw)      firewall_generate_ipfw "$fw_wan" ;;
            esac
            firewall_generate_fail2ban "$fw_os" "$fw_backend"
            firewall_generate_sysctl "$fw_os"
            echo

            if confirm "Install configs to system paths now? (requires sudo)"; then
                firewall_install_configs "$fw_os" "$fw_backend"
            else
                info "Configs saved to ${FIREWALL_STAGE_DIR}/ — install manually"
                info "Run later:  ./ashchan firewall:setup"
            fi
        else
            info "Skipped — run later with:  ./ashchan firewall:setup"
        fi
    else
        warn "No firewall backend detected — skipping"
        info "Install nftables/iptables/firewalld (Linux) or pf/ipfw (FreeBSD)"
        info "Then run:  ./ashchan firewall:setup"
    fi

    # ─── 8. Nginx reverse proxy (optional) ───
    step "8/10  Nginx reverse proxy (optional)"
    if command -v nginx &>/dev/null; then
        info "nginx detected — it can sit in front of Anubis for TLS, rate limiting, and bot blocking"
        info "Architecture: nginx (80/443) → Anubis (8080) → API Gateway (9501)"
        echo
        if confirm "Configure nginx reverse proxy?"; then
            cmd_nginx_setup
        else
            info "Skipped — run later with:  ./ashchan nginx:setup"
        fi
    else
        info "nginx not installed — skipping reverse proxy setup"
        info "Install nginx and run:  ./ashchan nginx:setup"
        info "See docs/NGINX_HARDENING.md for guidance"
    fi

    # ─── 9. Start services ───
    step "9/10  Starting services"
    for svc in "${SVC_NAMES[@]}"; do
        svc_start "$svc"
        sleep 1
    done

    # Anubis (best-effort, not a numbered step)
    info "Starting Anubis (AI firewall)..."
    if check_anubis 2>/dev/null; then
        anubis_start || warn "Anubis not started — site runs without bot protection"
    else
        warn "Anubis not installed — skipping bot protection layer"
        info "Install from: https://github.com/TecharoHQ/anubis/releases"
        info "Then run:  ./ashchan anubis:start"
    fi

    # Start nginx if configured
    if command -v nginx &>/dev/null && [[ -f "$NGINX_CONF_DST" ]]; then
        nginx_start 2>/dev/null || true
    fi

    # ─── 10. Health ───
    step "10/10  Verifying health"
    sleep 3
    local healthy=0
    for svc in "${SVC_NAMES[@]}"; do
        if svc_health "$svc"; then
            success "${SVC_LABELS[$svc]} — healthy"
            healthy=$((healthy + 1))
        else
            warn "${SVC_LABELS[$svc]} — not responding yet"
        fi
    done
    if anubis_is_running && anubis_health; then
        success "Anubis (AI Firewall) — healthy"
    elif anubis_is_running; then
        warn "Anubis — not responding yet"
    fi
    if nginx_is_running; then
        if nginx_health; then
            success "nginx (reverse proxy) — healthy"
        else
            warn "nginx — running but health check failed (TLS cert may not be configured yet)"
        fi
    fi

    # ─── Summary ───
    echo
    echo -e "${M}══════════════════════════════════════════════════${NC}"
    echo -e "${BOLD}${G}  Installation complete!${NC}  (${healthy}/${#SVC_NAMES[@]} services healthy)"
    echo -e "${M}══════════════════════════════════════════════════${NC}"
    echo
    echo -e "  ${BOLD}Endpoints${NC}"
    separator
    if nginx_is_running; then
        printf "  %-22s https://localhost      ${DIM}(nginx → Anubis → Gateway)${NC}\n" "Public frontend"
    elif anubis_is_running; then
        printf "  %-22s http://localhost:%s  ${DIM}(via Anubis)${NC}\n" "Public frontend" "${ANUBIS_PORT}"
    fi
    for svc in "${SVC_NAMES[@]}"; do
        printf "  %-22s http://localhost:%s\n" "${SVC_LABELS[$svc]}" "${SVC_PORTS[$svc]}"
    done
    echo
    echo -e "  ${BOLD}Infrastructure (required separately)${NC}"
    separator
    echo "  PostgreSQL             localhost:5432"
    echo "  Redis                  localhost:6379"
    echo "  MinIO                  localhost:9000"
    echo
    echo -e "  ${BOLD}Quick reference${NC}"
    separator
    echo "  ./ashchan status       Show service status"
    echo "  ./ashchan logs         Tail combined logs"
    echo "  ./ashchan restart      Restart all services"
    echo "  ./ashchan stop         Stop everything"
    echo
    echo -e "  ${Y}╔════════════════════════════════════════════════╗${NC}"
    echo -e "  ${Y}║  ${BOLD}DEFAULT ADMIN CREDENTIALS${NC}${Y}                       ║${NC}"
    echo -e "  ${Y}║  Username: admin    Password: admin123        ║${NC}"
    echo -e "  ${Y}║  ${R}⚠ CHANGE THIS IMMEDIATELY${NC}${Y}                      ║${NC}"
    echo -e "  ${Y}╚════════════════════════════════════════════════╝${NC}"
    echo
}

# ─────────────────────────────────────────────────────────────────────────────
# Help
# ─────────────────────────────────────────────────────────────────────────────

cmd_help() {
    banner "All-in-one CLI"
    echo -e "  ${BOLD}Usage:${NC}  ./ashchan ${C}<command>${NC} [options]"
    echo
    echo -e "  ${BOLD}Setup${NC}"
    echo -e "    ${C}install${NC}            Full first-time setup"
    echo -e "    ${C}compile${NC}            Install composer dependencies"
    echo
    echo -e "  ${BOLD}Services${NC}"
    echo -e "    ${C}start${NC}  [service]   Start all or one service"
    echo -e "    ${C}stop${NC}   [service]   Stop all or one service"
    echo -e "    ${C}restart${NC} [service]  Restart all or one service"
    echo -e "    ${C}status${NC}             Show status and health"
    echo -e "    ${C}logs${NC}   [service]   Tail service logs"
    echo
    echo -e "  ${BOLD}Database${NC}"
    echo -e "    ${C}db:install${NC}         Apply schema (db/install.sql)"
    echo -e "    ${C}db:seed${NC}            Seed initial data (db/seed.sql)"
    echo -e "    ${C}db:reset${NC}           Drop all tables and reinstall"
    echo
    echo -e "  ${BOLD}Certificates${NC}"
    echo -e "    ${C}certs:init${NC}         Generate root CA"
    echo -e "    ${C}certs:generate${NC}     Generate all service certs"
    echo -e "    ${C}certs:rotate${NC}       Rotate certs + rolling restart"
    echo -e "    ${C}certs:status${NC}       Show certificate expiry"
    echo -e "    ${C}certs:verify${NC}       Verify the mTLS chain"
    echo
    echo -e "  ${BOLD}Anubis (AI Firewall)${NC}"
    echo -e "    ${C}anubis:start${NC}       Start Anubis reverse proxy"
    echo -e "    ${C}anubis:stop${NC}        Stop Anubis"
    echo -e "    ${C}anubis:restart${NC}     Restart Anubis"
    echo -e "    ${C}anubis:status${NC}      Show Anubis status"
    echo
    echo -e "  ${BOLD}Build${NC}"
    echo -e "    ${C}build${NC}              Build all static binaries"
    echo -e "    ${C}build:php${NC}          Build only the static PHP runtime"
    echo -e "    ${C}build:clean${NC}        Remove static build artifacts"
    echo -e "    ${C}build:<service>${NC}    Build one service as static binary"
    echo
    echo -e "  ${BOLD}Security${NC}"
    echo -e "    ${C}nginx:setup${NC}        Configure nginx reverse proxy (TLS + rate limits)"
    echo -e "    ${C}nginx:cloudflare${NC}   Setup Cloudflare origin pulls + real IP ranges"
    echo -e "    ${C}nginx:start${NC}        Start nginx"
    echo -e "    ${C}nginx:stop${NC}         Stop nginx"
    echo -e "    ${C}nginx:reload${NC}       Reload nginx config"
    echo -e "    ${C}nginx:status${NC}       Show nginx status"
    echo -e "    ${C}firewall:setup${NC}     Configure firewall + fail2ban + sysctl hardening"
    echo
    echo -e "  ${BOLD}Quality${NC}"
    echo -e "    ${C}lint${NC}               Check PHP syntax"
    echo -e "    ${C}test${NC}               Run PHPUnit test suites"
    echo
    echo -e "  ${BOLD}Maintenance${NC}"
    echo -e "    ${C}clean${NC}              Remove logs, PIDs, caches"
    echo -e "    ${C}help${NC}               Show this help"
    echo
    echo -e "  ${BOLD}Services:${NC} gateway, auth, boards, media, search, moderation, anubis, nginx"
    echo
    echo -e "  ${BOLD}Options:${NC}"
    echo -e "    ${C}--force${NC}            Force regeneration of certs/env files"
    echo
    echo -e "  ${BOLD}Environment variables:${NC}"
    echo -e "    DB_HOST, DB_PORT, DB_USER, DB_NAME, DB_PASS"
    echo -e "    REDIS_HOST, REDIS_PASSWORD"
    echo
}

# ─────────────────────────────────────────────────────────────────────────────
# Main dispatcher
# ─────────────────────────────────────────────────────────────────────────────

main() {
    local cmd="${1:-help}"
    shift || true

    # Global flags
    for arg in "$@"; do
        case "$arg" in
            --force) FORCE=1 ;;
        esac
    done
    # Filter out flags from positional args
    local args=()
    for arg in "$@"; do
        [[ "$arg" == --* ]] || args+=("$arg")
    done

    case "$cmd" in
        install)
            cmd_install
            ;;
        start)
            banner "Starting services"
            local target="${args[0]:-all}"
            if [[ "$target" == "all" ]]; then
                for svc in "${SVC_NAMES[@]}"; do svc_start "$svc"; sleep 0.5; done
                anubis_start 2>/dev/null || true
                nginx_start 2>/dev/null || true
            elif [[ "$target" == "anubis" ]]; then
                anubis_start
            elif [[ "$target" == "nginx" ]]; then
                nginx_start
            else
                if [[ -n "${SVC_DIRS[$target]+x}" ]]; then
                    svc_start "$target"
                else
                    die "Unknown service: ${target}. Available: ${SVC_NAMES[*]} anubis nginx"
                fi
            fi
            ;;
        stop)
            banner "Stopping services"
            local target="${args[0]:-all}"
            if [[ "$target" == "all" ]]; then
                nginx_stop 2>/dev/null || true
                anubis_stop 2>/dev/null || true
                for svc in "${SVC_NAMES[@]}"; do svc_stop "$svc"; done
            elif [[ "$target" == "anubis" ]]; then
                anubis_stop
            elif [[ "$target" == "nginx" ]]; then
                nginx_stop
            else
                if [[ -n "${SVC_DIRS[$target]+x}" ]]; then
                    svc_stop "$target"
                else
                    die "Unknown service: ${target}. Available: ${SVC_NAMES[*]} anubis nginx"
                fi
            fi
            ;;
        restart)
            banner "Restarting services"
            local target="${args[0]:-all}"
            if [[ "$target" == "all" ]]; then
                nginx_stop 2>/dev/null || true
                anubis_stop 2>/dev/null || true
                for svc in "${SVC_NAMES[@]}"; do svc_stop "$svc"; done
                sleep 1
                for svc in "${SVC_NAMES[@]}"; do svc_start "$svc"; sleep 0.5; done
                anubis_start 2>/dev/null || true
                nginx_start 2>/dev/null || true
            elif [[ "$target" == "anubis" ]]; then
                anubis_stop
                sleep 1
                anubis_start
            elif [[ "$target" == "nginx" ]]; then
                nginx_stop
                sleep 1
                nginx_start
            else
                if [[ -n "${SVC_DIRS[$target]+x}" ]]; then
                    svc_stop "$target"
                    sleep 1
                    svc_start "$target"
                else
                    die "Unknown service: ${target}. Available: ${SVC_NAMES[*]} anubis nginx"
                fi
            fi
            ;;
        status)
            banner
            cmd_status
            ;;
        logs)
            cmd_logs "${args[0]:-all}"
            ;;
        db:install)
            banner "Database"
            cmd_db_install
            ;;
        db:seed)
            banner "Database"
            cmd_db_seed
            ;;
        db:reset)
            banner "Database"
            cmd_db_reset
            ;;
        certs:init)
            banner "Certificates"
            certs_init_ca
            ;;
        certs:generate)
            banner "Certificates"
            certs_generate_all
            ;;
        certs:rotate)
            banner "Certificates"
            certs_rotate
            ;;
        certs:status)
            banner "Certificates"
            certs_status
            ;;
        certs:verify)
            banner "Certificates"
            certs_verify
            ;;
        compile)
            banner "Compile"
            check_php
            check_composer
            compile_services
            ;;
        build)
            banner "Static Build"
            cmd_build "${args[0]:-all}"
            ;;
        build:php)
            banner "Static Build"
            cmd_build php
            ;;
        build:clean)
            banner "Static Build"
            cmd_build clean
            ;;
        build:*)
            banner "Static Build"
            local svc_target="${cmd#build:}"
            cmd_build "$svc_target"
            ;;
        firewall:setup)
            cmd_firewall_setup
            ;;
        nginx:setup)
            cmd_nginx_setup
            ;;
        nginx:cloudflare)
            cmd_nginx_cloudflare
            ;;
        nginx:start)
            banner "Nginx"
            nginx_start
            ;;
        nginx:stop)
            banner "Nginx"
            nginx_stop
            ;;
        nginx:reload)
            banner "Nginx"
            nginx_reload
            ;;
        nginx:restart)
            banner "Nginx"
            nginx_stop
            sleep 1
            nginx_start
            ;;
        nginx:status)
            banner "Nginx"
            step "nginx reverse proxy status"
            if nginx_is_running; then
                success "Running"
                if nginx_health; then
                    success "Health: OK"
                else
                    warn "Health: not responding (TLS cert may not be configured)"
                fi
                info "Config: ${NGINX_CONF_DST}"
                info "Logs:   /var/log/nginx/"
                info "Target: http://127.0.0.1:${ANUBIS_PORT} (Anubis)"
            else
                info "Not running"
                info "Start with:  ./ashchan nginx:start"
            fi
            echo
            ;;
        lint)
            banner "Lint"
            cmd_lint
            ;;
        test)
            banner "Test"
            cmd_test
            ;;
        anubis:start)
            banner "Anubis"
            anubis_start
            ;;
        anubis:stop)
            banner "Anubis"
            anubis_stop
            ;;
        anubis:restart)
            banner "Anubis"
            anubis_stop
            sleep 1
            anubis_start
            ;;
        anubis:status)
            banner "Anubis"
            step "Anubis AI Firewall status"
            if anubis_is_running; then
                success "Running (PID $(anubis_pid), port ${ANUBIS_PORT})"
                if anubis_health; then
                    success "Health: OK"
                else
                    warn "Health: not responding"
                fi
                info "Policy: ${ANUBIS_DIR}/policy.yaml"
                info "Logs:   ${LOG_DIR}/ashchan-anubis.log"
                info "Target: http://localhost:${SVC_PORTS[gateway]} (API Gateway)"
            else
                info "Not running"
                info "Start with:  ./ashchan anubis:start"
            fi
            echo
            ;;
        clean)
            banner "Cleanup"
            cmd_clean
            ;;
        help|--help|-h)
            cmd_help
            ;;
        *)
            fail "Unknown command: ${cmd}"
            echo
            cmd_help
            exit 1
            ;;
    esac
}

main "$@"
